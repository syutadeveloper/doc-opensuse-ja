<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter [
<!ENTITY % entities SYSTEM "entity-decl.ent">
%entities;
]>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="cha.apache2">
 <title>Apache HTTP サーバ</title>
 <info>
  <abstract>
   <para><link xlink:href="http://www.netcraft.com/"/> の調査によると、 Apache HTTP サーバ (Apache) は世界で最も使われている Web サーバです。この Web サーバは Apache Software Foundation ( <link xlink:href="http://www.apache.org/"/> ) によって開発されているソフトウエアで、ほとんどのオペレーティングシステムで動作します。 &productnamereg; では Apache バージョン 2.4 が同梱されています。本章では、 Web サーバのインストールから設定のほか、 SSL や CGI などの追加モジュールの設定方法やトラブルシューティングまでの範囲を説明しています。</para>
  </abstract>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker/>
   <dm:translation>yes</dm:translation>
  </dm:docmanager>
 </info>
 <sect1 xml:id="sec.apache2.quickstart">
  <title>クイックスタート</title>

  <para>本章では、 Apache を手短かに設定して起動するまでの手順を説明しています。なお、 Apache のインストールと設定は、 &rootuser; で行なわなければなりません。</para>

  <sect2 xml:id="sec.apache.quickstart.requirements">
   <title>要件</title>
   <para>Apache Web サーバを設定しようとする前に、まずは下記の要件全てを満たしていることをご確認ください:</para>
   <orderedlist spacing="normal">
    <listitem>
     <para>対象となるマシンのネットワークが正しく設定されている必要があります。ネットワークの設定について、詳しくは <xref linkend="cha.network"/> をお読みください。</para>
    </listitem>
    <listitem>
     <para>対象となるマシンのシステム時刻が、タイムサーバとの間で正しく同期している必要があります。 HTTP プロトコルでは、時刻をベースにした仕組みを利用しているものがあるためです。詳しくは <xref linkend="cha.ntp"/> をお読みください。</para>
    </listitem>
    <listitem>
     <para>最新のセキュリティ更新を適用しておく必要があります。何か不安な点があれば、念のため &yast; オンライン更新を実行しておいてください。</para>
    </listitem>
    <listitem>
     <para>既定の Web サーバのポート ( <literal>80</literal> ) をファイアウオールで開く必要があります。ファイアウオールでポートを開くには、 &firewalld; で <literal>http</literal> サービスを公開ゾーンで許可する必要があります。詳しくは <xref linkend="sec.security.firewall.firewalld.cmd"/> をお読みください。</para>
    </listitem>
   </orderedlist>
  </sect2>

  <sect2 xml:id="sec.apache2.quickstart.installation">
   <title>インストール</title>
   <para>&productname; では、 Apache は既定ではインストールされません。インストールを行ない、標準的な <quote>出荷時設定</quote> で開始したい場合は、下記の手順を実施します:</para>
   <procedure>
    <title>既定の設定による Apache のインストール</title>
    <step>
     <para>&yast; を起動して、 <menuchoice> <guimenu>ソフトウエア</guimenu> <guimenu>ソフトウエア管理</guimenu> </menuchoice> を選択します。</para>
    </step>
    <step>
     <para><menuchoice> <guimenu>表示</guimenu> <guimenu>パターン</guimenu> </menuchoice> を選択し、 <guimenu>Web および LAMP サーバ</guimenu> にチェックを入れます。</para>
    </step>
    <step>
     <para>あとは <guimenu>了解</guimenu> を押して、インストール処理を完了します。依存関係のパッケージ一覧が表示されますので、こちらでも <guimenu>続行</guimenu> を押してください。</para>
    </step>
   </procedure>
  </sect2>

  <sect2 xml:id="sec.apache.quickstart.start">
   <title>起動</title>
   <para>Apache はシステムの起動時に自動的に開始することができるほか、手作業で開始することもできます。</para>
   <para>Apache をシステムの起動時に自動的に開始したい場合は、 <literal>multi-user.target</literal> と <literal>graphical.target</literal> のターゲット内に Apache を追加します。具体的には、下記のコマンドを実行します:</para>
<screen>&prompt.sudo;systemctl enable apache2</screen>
   <para><remark>taroth 2014-02-11: commenting the following procedure as it is unsure how to enable a service for certain targets with YaST Services Manager, filed bnc# 863333 for it UPDATE tbazant 2015-08-20: still not clear, leaving commented out </remark></para>
   <para>&productname; における systemd のターゲットに関する説明や、 &yast; の <guimenu>&ycc_runlevel;</guimenu> の説明について、詳しくは <xref linkend="sec.boot.runlevel.edit"/> をお読みください。</para>
   <para>シェルを利用して Apache を手作業で開始したい場合は、 <command>systemctl start apache2</command> を実行します。</para>
   <procedure>
    <title>Apache が動作しているかどうかの確認</title>
    <para>Apache の開始時に何もエラーメッセージが表示されない場合は、 Web サーバが問題なく起動して動作していることを表わしています。動作確認を行なうには、下記の手順で行ないます:</para>
    <step>
     <para>ブラウザを起動して <link xlink:href="http://localhost/"/> を開きます。</para>
     <para>Apache が開始されていて動作していれば、 <quote>It works!</quote> というメッセージが表示されるはずです。</para>
    </step>
    <step>
     <para>このようなページが表示されない場合は、 <xref linkend="sec.apache2.troubleeshooting"/> をご覧ください。</para>
    </step>
   </procedure>
   <para>Web サーバが動作していることを確認できたら、あとは必要な文書を追加したり、必要に応じて設定を調整したり、モジュールを追加して機能を追加したりすることができるようになります。</para>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.apache2.configuration">
  <title>Apache の設定</title>

  <para>&productname; では 2 種類の設定方法を用意しています:</para>

  <itemizedlist mark="bullet" spacing="normal">
   <listitem>
    <para><xref linkend="sec.apache2.configuration.manually" xrefstyle="select:title"/></para>
   </listitem>
   <listitem>
    <para><xref linkend="sec.apache2.configuration.yast" xrefstyle="select:title"/></para>
   </listitem>
  </itemizedlist>

  <para>手作業で設定を行なうと、より細かいところまで設定を行なうことができますが、 &yast; GUI ほどの利便性はありません。</para>

  <important>
   <title>設定変更後の Apache の再読み込みもしくは再起動について</title>
   <para>設定を変更した場合は、設定を反映させるために Apache の再読み込み (場合によっては再起動) が必要となります。手作業で再読み込みを行ないたい場合は、 <command>systemctl reload apache2</command> を実行してください。また、再起動は <xref linkend="sec.apache2.start_stop"/> に示されているいずれかの方法を実行してください。</para>
   <para>&yast; で Apache を設定した場合は、 <guimenu>HTTP サービス</guimenu> が <guimenu>有効</guimenu> に設定されていると、再読み込みを自動的に実施するようになっています。詳しくは <xref linkend="sec.apache2.configuration.yast.server_configuration"/> をお読みください。</para>
  </important>

  <sect2 xml:id="sec.apache2.configuration.manually.configfiles">
   <title>Apache の設定ファイル</title>
   <para>本章では、 Apache の設定ファイルに関する概要説明を行なっています。設定にあたって &yast; を使用している場合は、これらのファイルを直接編集する必要はありません。しかしながら、あとから手作業で編集するように切り替える場合に備えて、あらかじめいくつかの情報を知っておくと良いでしょう。</para>
   <para>Apache の設定ファイルは、下記の 2 箇所に配置されています:</para>
   <itemizedlist mark="bullet" spacing="normal">
    <listitem>
     <para><xref linkend="sec.apache2.configuration.manually.configfiles.etc_sysconfig_apache2" xrefstyle="select:title"/></para>
    </listitem>
    <listitem>
     <para><xref linkend="sec.apache2.configuration.manually.configfiles.etc_apache2" xrefstyle="select:title"/></para>
    </listitem>
   </itemizedlist>
   <sect3 xml:id="sec.apache2.configuration.manually.configfiles.etc_sysconfig_apache2">
    <title><filename>/etc/sysconfig/apache2</filename></title>
    <para><filename>/etc/sysconfig/apache2</filename> では、 Apache 全体のグローバル設定が提供されています。たとえば読み込むべきモジュールや取り込むべき追加の設定ファイル、サーバを起動する際のフラグやコマンドラインに追加すべき設定などがあります。このファイル内での全ての設定オプションは、設定ファイル内にコメントで説明しているため、ここでは詳しく説明しません。一般的な Web サーバであれば、 <filename>/etc/sysconfig/apache2</filename> を設定するだけで、要件に十分対応することができるはずです。</para>
   </sect3>
   <sect3 xml:id="sec.apache2.configuration.manually.configfiles.etc_apache2">
    <title><filename>/etc/apache2/</filename></title>
    <para><filename>/etc/apache2/</filename> には Apache に対する全ての設定ファイルが含まれています。下記ではそれぞれのファイルの用途を説明しています。各ファイルにはいくつかの設定オプション (<emphasis>ディレクティブ</emphasis> と呼びます) が用意されていますが、同様にこれらのファイルのコメント内に説明が書かれています。そのため、こちらもここでは詳しく説明しません。</para>
    <para>Apache の設定ファイルは、下記のような構成になっています:</para>
<screen>/etc/apache2/
     |
     |- charset.conv
     |- conf.d/
     |   |
     |   |- *.conf
     |
     |- default-server.conf
     |- errors.conf
     |- httpd.conf
     |- listen.conf
     |- magic
     |- mime.types
     |- mod_*.conf
     |- server-tuning.conf
     |- ssl.*
     |- ssl-global.conf
     |- sysconfig.d
     |   |
     |   |- global.conf
     |   |- include.conf
     |   |- loadmodule.conf . .
     |
     |- uid.conf
     |- vhosts.d
     |   |- *.conf</screen>
    <variablelist>
     <title>/etc/apache2/ 内の Apache 設定ファイル</title>
     <varlistentry>
      <term><filename>charset.conv</filename></term>
      <listitem>
       <para>様々な言語でどの文字セットを使用するのかを指定しています。このファイルについては編集してはなりません。</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><filename>conf.d/*.conf</filename></term>
      <listitem>
       <para>他のモジュールによって追加された設定ファイルが保存されます。これらの設定ファイルは、必要に応じて仮想ホストの設定ファイルから取り込むことができます。使用例について、詳しくは <filename>vhosts.d/vhost.template</filename> をお読みください。また、これを行なうことで、それぞれの仮想ホストに対して別々のモジュールセットを提供することができるようになります。</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><filename>default-server.conf</filename></term>
      <listitem>
       <para>適切な既定値が設定された、全ての仮想ホスト向けのグローバル設定です。ここに書かれている値を書き換えるのではなく、仮想ホストの設定ファイル内で値を指定して変更するようにしてください。</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><filename>errors.conf</filename></term>
      <listitem>
       <para>Apache のエラー応答方法を定義しています。全ての仮想ホストに対してエラーメッセージをカスタマイズしたい場合は、このファイルを編集してください。それぞれの仮想ホストで別々のエラーメッセージを設定したい場合は、それぞれの仮想ホストの設定内で設定を行なってください。</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><filename>httpd.conf</filename></term>
      <listitem>
       <para>Apache のメインの設定ファイルです。このファイルを変更することは避けてください。主にステートメントとグローバル設定が含まれています。設定を変更したい場合は、対応する設定ファイル内で設定を行なってください。また、ホスト固有の設定 (たとえばドキュメントルートなど) を行ないたい場合は、仮想ホストの設定で行なってください。</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><filename>listen.conf</filename></term>
      <listitem>
       <para>Apache がどの IP アドレスやポートで待ち受けるかを設定するファイルです。名前ベースの仮想ホストについても、ここで設定を行ないます。詳しくは <xref linkend="sec.apache2.configuration.manually.vhost.named_vhosts"/> をお読みください。</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><filename>magic</filename></term>
      <listitem>
       <para>Apache が未知のファイルに対して MIME タイプを自動判別する際に使用する、 mime_magic モジュール向けのデータファイルです。このファイルを変更してはなりません。</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><filename>mime.types</filename></term>
      <listitem>
       <para>システム側で既知の MIME タイプを一覧で示しているファイルです (実際には <filename>/etc/mime.types</filename> へのリンクになっています) 。このファイルについても、変更を行なってはなりません。ここに書かれていない MIME タイプを追加したい場合は、 <filename>mod_mime-defaults.conf</filename> ファイルに追加を行なってください。</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><filename>mod_*.conf</filename></term>
      <listitem>
       <para>既定でインストールされるモジュール向けの設定ファイルです。詳しくは <xref linkend="sec.apache2.modules"/> をお読みください。なお、オプションモジュール向けの設定ファイルは、 <filename>conf.d</filename> ディレクトリ内に存在しています。</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><filename>server-tuning.conf</filename></term>
      <listitem>
       <para>様々な MPM (詳しくは <xref linkend="sec.apache2.modules.mpm"/> をお読みください) に対する設定ディレクティブと、 Apache の性能を制御するための一般的な設定オプションが含まれています。このファイル内の設定を変更するにあたっては、お使いの Web サーバで十分なテストを行なってください。</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><filename>ssl-global.conf</filename> および <filename>ssl.*</filename></term>
      <listitem>
       <para>SSL の全体設定と SSL の証明書ファイルが含まれています。詳しくは <xref linkend="sec.apache2.ssl"/> をお読みください。</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><filename>sysconfig.d/*.conf</filename></term>
      <listitem>
       <para><filename>/etc/sysconfig/apache2</filename> から自動生成された設定ファイルです。これらのファイルについては変更せず、 <filename>/etc/sysconfig/apache2</filename> を変更して対応してください。また、このディレクトリには他の設定ファイルを配置しないでください。</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><filename>uid.conf</filename></term>
      <listitem>
       <para>Apache を動作させる際のユーザ ID とグループ ID を指定しています。このファイルについても変更してはなりません。</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><filename>vhosts.d/*.conf</filename></term>
      <listitem>
       <para>仮想ホストの設定は、この形式で保存する必要があります。このディレクトリ内には、 SSL ありの場合と無しの場合に対応する、仮想ホストの設定テンプレート (雛形) が用意されています。また、 Apache の設定ファイルとして自動的に取り込むには、ファイル名の末尾が <filename>.conf</filename> で終わっていなければなりません。詳しくは <xref linkend="sec.apache2.configuration.manually.vhost"/> をお読みください。</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
  </sect2>

  <sect2 xml:id="sec.apache2.configuration.manually">
   <title>Apache の手作業での設定</title>
   <para>Apache を手作業で設定するにあたっては、純粋なテキストファイルで書かれている設定ファイルを <systemitem class="username">root</systemitem> で編集する必要があります。</para>
   <sect3 xml:id="sec.apache2.configuration.manually.vhost">
    <title>仮想ホストの設定</title>
    <para>Apache における <emphasis>仮想ホスト</emphasis> とは、同一の物理マシン内で複数の統一資源識別子 (URI) を賄う仕組みです。たとえば &wwwname; や &wwwname1; などの異なるドメイン名の Web サーバを、 1 台の物理マシン内にある 1 つの Web サーバで提供することができます。</para>
    <para>仮想ホストの使用は、管理費用の削減 (管理すべき Web サーバを 1 台にまとめることができる) やハードウエア費用の削減 (それぞれのドメインに対して別々の専用サーバを用意する必要が無くなる) などの効果がある実践的な方法です。仮想ホストは名前 (ドメイン名, ホスト名) ベースのほか、 IP ベースやポートベースでも設定することができます。</para>
    <para>設定済みの仮想ホストを一覧表示したい場合は、 <command>apache2ctl</command> <option>-S</option> を実行します。これにより、既定のサーバと全ての仮想ホストが一覧表示することができるほか、待ち受ける IP アドレスとポートも表示することができます。これに加えて、それぞれの仮想ホストが指定されている設定ファイル内の場所も表示することができます。</para>
    <para>仮想ホストは <xref linkend="sec.apache2.configuration.yast.wizard.virtual_hosts"/> で説明しているとおり &yast; で設定することができるほか、設定ファイルを直接編集して設定することもできます。既定では、 &productname; 内の Apache は <filename>/etc/apache2/vhosts.d/</filename> ディレクトリ内にある 1 つのファイルで 1 つの仮想ホストを設定します。また、 Apache の設定ファイルとして自動的に取り込むには、ファイル名の末尾が <filename>.conf</filename> で終わっていなければなりません。また、このディレクトリ内には、仮想ホストを設定するためのテンプレート (雛形) も用意されています。 SSL 無しの場合は <filename>vhost.template</filename> を、 SSL ありの場合は <filename>vhost-ssl.template</filename> をご覧ください。</para>
    <tip>
     <title>仮想ホストの作成について</title>
     <para>お使いの Web サーバに 1 つのドメインしか存在しないような場合であっても、仮想ホストの設定ファイルを作成しておくことをお勧めします。これにより、ドメイン固有の設定を 1 つのファイルにまとめることができるだけでなく、仮想ホストの設定ファイルを移動したり削除したり名前変更したりするだけで、容易に元の設定に戻すことができるようになります。複数のドメインが存在する場合も同じ理由により、それぞれの仮想ホストに対してそれぞれ設定ファイルを個別に作成することをお勧めします。</para>
     <para>名前ベースの仮想ホストを使用する場合は、どの仮想ホストの設定にも該当しなかった場合に備えて、その他のドメインの場合 (既定の仮想ホスト) の設定ファイルを作成しておくことをお勧めします。 Apache では、設定ファイルの中で最初に読み込まれる仮想ホストが既定の仮想ホストに設定されますが、読み込みの順序はファイル名で判断される仕組みになっていますので、たとえばファイル名の最初に ( <literal>_</literal> ) 文字を入れるなど (例: <filename>_default_vhost.conf</filename>) して、最初に読み込まれるようにすると良いでしょう。</para>
    </tip>
    <para><systemitem>&lt;VirtualHost&gt;</systemitem> から <systemitem>&lt;/VirtualHost&gt;</systemitem> までのブロックには、特定のドメイン (仮想ホスト) にのみ適用される設定を記述します。 Apache が設定済みの仮想ホストに対する要求を受け取ると、対応するセクション内に書かれた設定を利用して要求を処理します。仮想ホストのブロックには、ほとんど全てのディレクティブを記述することができます。 Apache の設定ディレクティブについて、詳しくは <link xlink:href="http://httpd.apache.org/docs/2.4/mod/quickreference.html"/> をお読みください。</para>
    <sect4 xml:id="sec.apache2.configuration.manually.vhost.named_vhosts">
     <title>名前ベースの仮想ホスト</title>
     <para>名前ベースの仮想ホストを使用すると、複数の Web サイトを 1 つの IP アドレスで提供できるようになります。 Apache では、クライアントが送信する HTTP ヘッダ内の Host フィールドを、それぞれの仮想ホスト設定の <systemitem>ServerName</systemitem> と比較して、一致する仮想ホストを使用するようになっています。該当する <systemitem>ServerName</systemitem> が見つからない場合は、一番最初に設定された仮想ホストを既定で使用するようになっています。</para>
     <para><literal>&lt;VirtualHost&gt;</literal> ブロックを作成するにあたって最初にやるべきことは、提供する名前ベースの仮想ホストの名前の設定です。それぞれの <literal>&lt;VirtualHost&gt;</literal> ブロック内に <literal>ServerName</literal> ディレクティブを指定してドメイン名を指定し、そのドメイン名にアクセスがあった場合に、どのディレクトリからファイルを提供するのかを <literal>DocumentRoot</literal> ディレクティブで指定します。</para>
     <example xml:id="ex.apache2.virtual_hosts.name_based">
      <title>名前ベースの仮想ホスト (<systemitem>VirtualHost</systemitem>) の設定例</title>
<screen>&lt;VirtualHost *:80&gt;
# 最初に記述された仮想ホストが既定のホストになります
ServerName www.example.com
ServerAlias example.com
DocumentRoot /srv/www/htdocs/domain
&lt;/VirtualHost&gt;

&lt;VirtualHost *:80&gt;
ServerName other.example.com
DocumentRoot /srv/www/htdocs/otherdomain
&lt;/VirtualHost&gt;</screen>
     </example>
     <para>名前ベースの仮想ホストを設定する場合、開く側の <systemitem>VirtualHost</systemitem> タグには IP アドレス (もしくは完全修飾ドメイン名) をパラメータとして指定します。ポート番号は指定しても指定していなくてもかまいません。</para>
     <para>なお、 IP アドレスの代わりにワイルドカード <emphasis>*</emphasis> を指定することもできます。 IPv6 アドレスを指定する場合、アドレスは角括弧で括らなければなりません。</para>
     <example xml:id="ex.apache.directives.virtualhost.name_based">
      <title>名前ベースの仮想ホスト (<systemitem>VirtualHost</systemitem>) の設定</title>
<screen>&lt;VirtualHost &wwwip;:80&gt;
  ...
&lt;/VirtualHost&gt;

&lt;VirtualHost &wwwip;&gt;
  ...
&lt;/VirtualHost&gt;

&lt;VirtualHost *:80&gt;
  ...
&lt;/VirtualHost&gt;

&lt;VirtualHost *&gt;
  ...
&lt;/VirtualHost&gt;

&lt;VirtualHost [&wwwipv6;]&gt;
  ...
&lt;/VirtualHost&gt;</screen>
     </example>
    </sect4>
    <sect4 xml:id="sec.apache2.configuration.manually.vhost.ip_vhosts">
     <title>IP ベースの仮想ホスト</title>
     <para>IP ベースの仮想ホストを設定するにあたっては、マシンに対して複数の IP アドレスを設定しておかなければなりません。 IP ベースの仮想ホストでも、 Apache は 1 つのインスタンスで複数のドメインに対応することができます (それぞれ異なる IP アドレスに対応する必要があります) 。</para>
     <para>言い換えると、 IP ベースの仮想ホストを使用するにあたっては、物理サーバ側に仮想ホストの数と同じだけの IP アドレスを設定する必要があります。ただし、ネットワークカードについては、仮想ホストの数と同じだけ存在する必要はありません。 1 つのネットワークカードに複数の IP アドレスを設定すれば十分です。</para>
     <para>下記の例では、 <systemitem class="ipaddress">&wwwip;</systemitem> の IP アドレスを持つマシンで Apache を動作させ、追加で設定した 2 つの IP アドレスを利用して <systemitem class="ipaddress">&wwwip1;</systemitem> と <systemitem class="ipaddress">&wwwip2;</systemitem> のドメインを動作させています。それぞれの仮想ホストに対して、別々の <systemitem>VirtualHost</systemitem> を指定していることに注意してください。</para>
     <example xml:id="ex.apache.directives.virtualhost.ip_based">
      <title>IP ベースの仮想ホスト (<systemitem>VirtualHost</systemitem>) の設定</title>
<screen>&lt;VirtualHost &wwwip1;&gt;
  ...
&lt;/VirtualHost&gt;

&lt;VirtualHost &wwwip2;&gt;
  ...
&lt;/VirtualHost&gt;</screen>
     </example>
     <para>なお、この例では <systemitem>VirtualHost</systemitem> ディレクティブで <systemitem>&wwwip;</systemitem> の IP アドレスを設定していません。 <systemitem>Listen</systemitem> ディレクティブで <systemitem>&wwwip;</systemitem> の IP アドレスに対するアクセスを受け入れるように設定している場合は、 <systemitem>&wwwip;</systemitem> 向けの仮想ホストの設定も必要となります。設定を行なわない場合は、既定のサーバ設定 ( <filename>/etc/apache2/default-server.conf</filename> ) が適用されます。</para>
    </sect4>
    <sect4 xml:id="sec.apache2.configuration.manually.vhost.basic_configuration">
     <title>基本的な仮想ホストの設定</title>
     <para>仮想ホストを設定するにあたっては、少なくともそれぞれの仮想ホストの設定内に下記のディレクティブを設定する必要があります。それ以外のオプションについては <filename>/etc/apache2/vhosts.d/vhost.template</filename> をお読みください。</para>
     <variablelist>
      <varlistentry>
       <term><systemitem>ServerName</systemitem></term>
       <listitem>
        <para>その仮想ホストに対応する完全修飾ドメイン名を指定します。</para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><systemitem>DocumentRoot</systemitem></term>
       <listitem>
        <para>その仮想ホストが提供すべきファイルのあるディレクトリパスを指定します。また、セキュリティ上の理由から、既定ではファイルシステム全体へのアクセスが禁止されていますので、 <systemitem>Directory</systemitem> コンテナを利用して、ディレクトリに対するアクセスを許可しなければなりません。</para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><systemitem>ServerAdmin</systemitem></term>
       <listitem>
        <para>サーバ管理者の電子メールアドレスを指定します。このアドレスはたとえば、 Apache がエラーページを表示する際などに使用されます。</para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><systemitem>ErrorLog</systemitem></term>
       <listitem>
        <para>この仮想ホストに対するエラーログファイルを指定します。各仮想ホストに対して、それぞれ別々のエラーログファイルを用意する必要はありませんが、エラーへの対応を容易にする目的から、それぞれ別々にしておくことをお勧めします。なお、 Apache のログファイルの既定のディレクトリは、 <filename>/var/log/apache2/</filename> になっています。</para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><systemitem>CustomLog</systemitem></term>
       <listitem>
        <para>この仮想ホストに対するアクセスログファイルを指定します。各仮想ホストに対して、それぞれ別々のアクセスログを用意する必要はありませんが、それぞれの仮想ホストに対するアクセス解析を容易にする目的から、それぞれ別々にしておくことをお勧めします。なお、 Apache のログファイルの既定のディレクトリは、 <filename>/var/log/apache2/</filename> になっています。</para>
       </listitem>
      </varlistentry>
     </variablelist>
     <para>上述のとおり、ファイルシステム全体に対するアクセスは、セキュリティ上の理由から、規定で禁止されるようになっています。そのため、 Apache がファイルを提供するディレクトリに対しては、明示的に指定して許可を与える必要があります。たとえば <systemitem>DocumentRoot</systemitem> の場合は、下記のように設定します:</para>
<screen>&lt;Directory "/srv/www/&wwwname;/htdocs"&gt;
  Require all granted
&lt;/Directory&gt;</screen>
     <note>
      <title><literal>Require all granted</literal></title>
      <para>Apache の以前のバージョンでは、 <literal>Require all granted</literal> と同じ意味を持つ設定は下記のとおりです:</para>
<screen>Order allow,deny
Allow from all</screen>
      <para>この古い書式は、 <literal>mod_access_compat</literal> モジュールを読み込むことによって、現在も使用することができます。</para>
     </note>
     <para>これらを組み合わせると、完全な設定ファイルは下記のようになります:</para>
     <example xml:id="ex.apache.directives.virtualhost.basic_configuration">
      <title>基本的な <systemitem>VirtualHost</systemitem> の設定</title>
<screen>&lt;VirtualHost &wwwip;&gt;
  ServerName &wwwname;
  DocumentRoot /srv/www/&wwwname;/htdocs
  ServerAdmin webmaster@&exampledomain;
  ErrorLog /var/log/apache2/&wwwname;_log
  CustomLog /var/log/apache2/&wwwname;-access_log common
  &lt;Directory "/srv/www/&wwwname;/htdocs"&gt;
  Require all granted
  &lt;/Directory&gt;
&lt;/VirtualHost&gt;</screen>
     </example>
    </sect4>
   </sect3>
  </sect2>

<!-- YaST configuration -->

  <xi:include href="apache2_yast_i.xml"/>

<!-- /YaST configuration -->
 </sect1>
 <sect1 xml:id="sec.apache2.start_stop">
  <title>Apache の開始と停止</title>

  <remark>taroth 2014-02-11: @file-maintainer: please give the following a
 thorough check - so far I only replaced the rc* commands by the systemctl
 (and where those are not available, by apachectl commands as advised by
 crrodriguez), but the descriptions might need adjustment and some commands
 are probably no longer around, therefore I commented them</remark>

  <para><xref linkend="sec.apache2.configuration.yast"/> で説明している手順に従って &yast; で設定を行なった場合、 Apache は <systemitem>multi-user.target</systemitem> と <systemitem>graphical.target</systemitem> 内で、システムの起動時に自動的に開始されるようになります。この動作を変更したい場合は、 &yast; の <guimenu>&ycc_runlevel;</guimenu> を使用するか、もしくは <command>systemctl</command> コマンドラインツールをお使いください (<command>systemctl enable</command> もしくは <command>systemctl disable</command> を実行します) 。</para>

  <para>Apache の開始と停止、もしくは動作中の Apache に対して何らかの処理を行なわせたい場合は、下記のようにして <command>systemctl</command> もしくは <command>apachectl</command> コマンドをご利用ください。</para>

  <para><command>systemctl</command> コマンドに関する一般的な情報については、 <xref linkend="sec.boot.systemd.basics.services"/> をお読みください。</para>

  <variablelist>
   <varlistentry>
    <term><command>systemctl status apache2</command></term>
    <listitem>
     <para>Apache が動作しているかどうかを調べます。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><command>systemctl start apache2</command></term>
    <listitem>
     <para>Apache が動作していない場合、 Apache を開始します。</para>
    </listitem>
   </varlistentry>
<!-- taroth 2014-02-11: startssl no longer supported, can be achieched
    differently now, see
    http://httpd.apache.org/docs/2.4/programs/apachectl.html-->
<!--
  <varlistentry>
    <term><option>startssl</option>
   </term>
    <listitem>
     <para>
      Starts Apache with SSL support if it is not already running. For more
      information about SSL support, refer to
      <xref
        linkend="sec.apache2.ssl"/>.
     </para>
    </listitem>
   </varlistentry>
  -->
   <varlistentry>
    <term><command>systemctl stop apache2</command></term>
    <listitem>
     <para>親プロセスを終了させることで Apache を終了します。</para>
    </listitem>
   </varlistentry>
<!--   -->
   <varlistentry>
    <term><command>systemctl restart apache2</command></term>
    <listitem>
     <para>Apache を一旦停止して起動し直します。 Apache が動作中でなかった場合は、単純に開始します。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><command>systemctl try-restart apache2</command></term>
    <listitem>
     <para>動作中の場合にのみ、 Apache をいったん停止して起動し直します。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><command>systemctl reload apache2</command></term>
    <listitem>
     <para>全ての起動済み Apache プロセスに対して、現在処理中のリクエストの処理を完了してから終了するように促します。それぞれのプロセスが終了したタイミングで新しいプロセスを起動して入れ替えていき、最終的に Apache が完全に <quote>再起動</quote> できるようにします。</para>
     <tip>
      <title>本番環境における Apache の再起動について</title>
      <para>このコマンドを実行することで、クライアントから Apache への接続を強制的に終了させることなく、 Apache の設定変更を反映させることができるようになります。</para>
     </tip>
    </listitem>
   </varlistentry>
   <!-- <varlistentry>
    <term><command>apachectl -k graceful</command></term>
    <listitem>
     <para>
      Starts a second Web server that immediately serves all incoming requests.
      The previous instance of the Web server continues to handle all existing
      requests for a defined period of time configured with
      <systemitem>GracefulShutdownTimeout</systemitem>.
     </para>
     <para>
      This command is useful either when upgrading to a new version or when
      having changed configuration options that require a restart. Using this
      option ensures a minimum server downtime.
     </para>
     <para>
      If <systemitem>GracefulShutdownTimeout</systemitem> is set to zero, the
      server will wait indefinitely until all remaining requests have been
      fully served.
     </para>
     <para>
      A graceful restart can fail if the original Apache instance is not able
      to clear all necessary resources. In this case, the command will result
      in a graceful stop.
     </para>
    </listitem>
   </varlistentry> -->
   <varlistentry>
    <term><command>systemctl stop apache2</command></term>
    <listitem>
     <para>Web サーバを停止しますが、その際に <systemitem>GracefulShutdownTimeout</systemitem> で指定された長さの時間だけ終了を待機します。これにより、既存のリクエスト処理を正常に終了させることができるようになります。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><command>apachectl configtest</command></term>
    <listitem>
     <para>現在動作中の Web サーバに影響を与えずに、設定ファイルの文法をチェックします。このチェックはサーバの開始時や再読み込み時、再起動時にそれぞれ実行されるように設定されているため、このコマンドを明示的に実行する必要はありません (何らかの設定エラーが検出されると、開始／再読み込み／再起動を行なわないように設定されています) 。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><command>apachectl status</command> および <command>apachectl fullstatus</command></term>
    <listitem>
     <para>それぞれ現在の Apache サーバに関する情報を、短くもしくは長く表示します。この情報を表示するには、 <systemitem>mod_status</systemitem> モジュールを有効化する必要があるほか、テキストベースのブラウザ (たとえば <command>links</command> や <command>w3m</command> など) をインストールしておく必要があります。さらに、 <filename>/etc/sysconfig/apache2</filename> ファイル内の <systemitem>APACHE_SERVER_FLAGS</systemitem> に対して、 <literal>STATUS</literal> を追加しなければなりません。</para>
    </listitem>
   </varlistentry>
<!-- rcapache2 could do the following two, apachectl/systemctl cannot. -
sknorr, 2017-06-07 -->
<!-- original code:
  cmdline=$(echo $apache_bin -f $httpd_conf $server_flags "$@")
  out=$(su - nobody -c "$cmdline" 2>&1)
  case $out in
  *make_sock:\ could\ not\ bind\ to\ address*) echo Syntax: OK; rc_failed=0;;
  *) echo Syntax: NOT OK:; echo $out; rc_failed=1;;
  esac
  rc_exit -->
<!--The <option>extreme-configtest</option> options start the Web server as
      user <systemitem class="username">nobody</systemitem> and actually
      load the configuration, so more errors can be detected. Note that
      although the configuration is loaded, it is not possible to test the
      SSL setup because the SSL certificates cannot be read by
      <systemitem
       class="username">nobody</systemitem>.-->
<!--<varlistentry>
    <term><option>probe</option>
    </term>
    <listitem>
     <para>
      Probes for the necessity of a reload (checks whether the configuration
      has changed) and suggests the required arguments for the
      <command>rcapache2</command> command.
     </para>
    </listitem>
   </varlistentry>-->
<!-- original code:
  for i in $httpd_conf \
    $APACHE_CONF_INCLUDE_FILES \
    $APACHE_CONF_INCLUDE_DIRS
  do
  if [ $i -nt $pidfile ]; then
    echo reload
  break
  fi -->
  </variablelist>

  <tip>
   <title>追加フラグについて</title>
   <para>コマンドに対して追加のフラグを指定すると、それらは Web サーバにそのまま渡されます。</para>
  </tip>
 </sect1>
 <sect1 xml:id="sec.apache2.modules">
  <title>モジュールのインストール／有効化／設定</title>

  <para>Apache ソフトウエアはモジュール型の構造になっているため、いくつかの中枢機能を除くと、ほとんどの機能はモジュールとして作られています。 HTTP 自身でさえも、モジュールとして作られ処理されています (<systemitem>http_core</systemitem>) 。</para>

  <para>Apache のモジュールは構築時に Apache バイナリ内に組み込むことができるほか、実行時に動的に読み込むことができます。モジュールを動的に読み込む方法について、詳しくは <xref linkend="sec.apache2.modules.activating"/> をお読みください。</para>

  <para>Apache のモジュールは、下記の 4 種類の分野に分かれています:</para>

  <variablelist>
   <varlistentry>
    <term>基本モジュール</term>
    <listitem>
     <para>基本モジュールは、既定で Apache 内に組み込まれます。 &productname; での Apache では、 <systemitem>mod_so</systemitem> (他のモジュールを読み込むためのモジュール) と <systemitem>http_core</systemitem> のみが組み込まれます。それ以外のモジュールは共有オブジェクトとして提供され、サーバのバイナリファイルそのものに組み込まれずに、実行時に別途読み込む仕組みになっています。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>拡張モジュール</term>
    <listitem>
     <para>一般的に、拡張として位置づけられているモジュールは Apache ソフトウエア内に同梱されているものの、通常はサーバのバイナリファイル内に組み込まないものを意味します。 &productname; では、これらについても共有オブジェクトとして提供され、実行時に別途読み込む仕組みになっています。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>外部モジュール</term>
    <listitem>
     <para>外部モジュールとして位置づけられているモジュールは、公式の Apache ソフトウエア内には含まれていないものを意味します。 &productname; では、これらのうちのいくつかを提供しています。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>マルチプロセッシングモジュール (MPM)</term>
    <listitem>
     <para>MPM は Web サーバに対するリクエストを受け付け、処理するためのモジュールです。 Web サーバソフトウエアの中枢部分でもあります。</para>
    </listitem>
   </varlistentry>
  </variablelist>

  <sect2 xml:id="sec.apache2.modules.installing">
   <title>モジュールのインストール</title>
   <para><xref linkend="sec.apache2.quickstart.installation"/> の手順に従って既定のインストール作業を行なうと、全ての基本モジュールと拡張モジュールのほか、マルチプロセッシングモジュールである Prefork MPM と、外部モジュール <systemitem>mod_python</systemitem> がそれぞれインストールされます。</para>
   <para>追加の外部モジュールをインストールしたい場合は、 &yast; を起動して <menuchoice><guimenu>ソフトウエア</guimenu> <guimenu>ソフトウエア管理</guimenu></menuchoice> を選択し、 <menuchoice><guimenu>表示</guimenu><guimenu>検索</guimenu></menuchoice> を選択して <literal>apache</literal> と入力し、検索を行なってください。これにより、利用可能な全ての外部 Apache モジュールなどを表示することができます。</para>
  </sect2>

  <sect2 xml:id="sec.apache2.modules.activating">
   <title>有効化と無効化</title>
   <para>モジュールの有効化と無効化は、手作業で実施することができるほか、 &yast; でも設定することができます。 &yast; では、 <xref linkend="sec.apache2.configuration.yast.wizard"/> で説明しているとおり、スクリプト言語モジュール (PHP 5 および Python) を有効化もしくは無効化することができます。その他のモジュールの有効化と無効化については、 <xref linkend="sec.apache2.configuration.yast.server_configuration.modules"/> で説明しています。</para>
   <para>モジュールの有効化や無効化を手作業で実施したい場合は、 <command>a2enmod</command> <replaceable>モジュール名</replaceable> もしくは <command>a2dismod</command> <replaceable>モジュール名</replaceable> のコマンドをお使いください。 <command>a2enmod -l</command> と入力して実行すると、現時点で有効化されている全てのモジュールを一覧表示することができます。</para>
   <important>
    <title>外部モジュールに対する設定ファイルの取り込み</title>
    <para>外部モジュールを手作業で有効化した場合は、全ての仮想ホストの設定に対して、外部モジュールの設定ファイルが読み込まれていることをご確認ください。外部モジュールの設定ファイルは <filename>/etc/apache2/conf.d/</filename> 内に存在していて、既定では <filename>/etc/apache2/default-server.conf</filename> から読み込まれるようになっています。より細かい調整を行ないたい場合は、 <filename>/etc/apache2/default-server.conf</filename> 内にある外部モジュールに対する取り込み設定をコメントアウトして、特定の仮想ホストでのみ読み込むように設定してもかまいません。設定例については <filename>/etc/apache2/vhosts.d/vhost.template</filename> をお読みください。</para>
   </important>
  </sect2>

  <sect2 xml:id="sec.apache2.modules.base_extension">
   <title>基本モジュールと拡張モジュール</title>
   <para>全ての基本モジュールと拡張モジュールについては、 Apache のドキュメンテーション内に詳細説明が用意されています。下記では主要なモジュールに関する概要説明のみを行なっています。それぞれのモジュールに関する詳細は、 <link xlink:href="http://httpd.apache.org/docs/2.4/mod/">http://httpd.apache.org/docs/2.4/mod/</link> をお読みください。</para>
   <remark>taroth 2010-07-07: new module "mod_reqtimeout" to set timeouts and
    minimum data rates for receiving requests from a client (see changelog entry
    from Mar 08th 2010) -- module classified as "experimental" on the Apache
    Web site </remark>
   <variablelist>
    <varlistentry>
     <term><systemitem>mod_actions</systemitem></term>
     <listitem>
      <para>特定の MIME タイプ (たとえば <systemitem>application/pdf</systemitem> など) や特定の拡張子を持つファイル (たとえば <filename>.rpm</filename>) 、もしくは特定のリクエストメソッド (たとえば <systemitem>GET</systemitem>) が要求された際に、特定のスクリプトを実行する機能を提供します。このモジュールは既定で有効化されます。</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>mod_alias</systemitem></term>
     <listitem>
      <para><systemitem>Alias</systemitem> や <systemitem>Redirect</systemitem> のディレクティブを提供するモジュールです。これにより、特定の URL に対してディレクトリを割り当てる ( <systemitem>Alias</systemitem> の名前の通り、別名を定義する) ことができるほか、他の場所に転送を行なうことができます。このモジュールは既定で有効化されます。</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>mod_auth*</systemitem></term>
     <listitem>
      <para>様々な認証方式を提供する認証モジュールです。 <systemitem>mod_auth_basic</systemitem> はベーシック認証を、 <systemitem>mod_auth_digest</systemitem> はダイジェスト認証をそれぞれ提供します。</para>
      <para>なお、 <systemitem>mod_auth_basic</systemitem> と <systemitem>mod_auth_digest</systemitem> は、 <systemitem>mod_authn_*</systemitem> で表わされる認証プロバイダモジュールと、 <systemitem>mod_authz_*</systemitem> で表わされる認可モジュールを組み合わせて使用します。たとえば <systemitem>mod_authn_file</systemitem> はテキストファイルに認証情報を保存するモジュールであるほか、 <systemitem>mod_authz_user</systemitem> はユーザ認可を提供するモジュールです。</para>
      <para>この分野の説明について、詳しくは <link xlink:href="http://httpd.apache.org/docs/2.4/howto/auth.html"/> にある <citetitle>認証、承認、アクセス制御</citetitle> をお読みください。</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>mod_autoindex</systemitem></term>
     <listitem>
      <para>autoindex モジュールは、インデックスファイル (例: <filename>index.html</filename>) が存在しない場合に、ディレクトリ内の一覧を生成する機能を提供します。一覧の外観は様々に設定することができます。このモジュールについても既定で有効化されますが、ディレクトリ一覧の表示機能は <systemitem>Options</systemitem> ディレクティブで無効化されています。そのため、この機能が必要である場合は、お使いの仮想ホストの設定内で上書きしてお使いください。このモジュールの既定の設定ファイルは、 <filename>/etc/apache2/mod_autoindex-defaults.conf</filename> に配置されています。</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>mod_cgi</systemitem></term>
     <listitem>
      <para><systemitem>mod_cgi</systemitem> は CGI スクリプトを実行する際に必要となるモジュールです。このモジュールは既定で有効化されます。</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>mod_deflate</systemitem></term>
     <listitem>
      <para>このモジュールを使用すると、 Apache が特定のファイルを配信する際、その場でデータ圧縮を行なうことができるようになります。</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>mod_dir</systemitem></term>
     <listitem>
      <para><systemitem>mod_dir</systemitem> は <systemitem>DirectoryIndex</systemitem> ディレクティブを提供するモジュールで、ディレクトリそのものに対してリクエストが届いた際に、どのファイルを自動的に配信するかを指定します。既定値は <filename>index.html</filename> に設定されています。また、このモジュールは、ディレクトリに対するリクエストが届いた場合、末尾がスラッシュで終わっていないと、末尾のスラッシュを追加する (実際にはそのような URL に転送する) 機能も提供します。このモジュールも既定で有効化されます。</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>mod_env</systemitem></term>
     <listitem>
      <para>CGI スクリプトや SSI ページに対して渡される、環境変数の制御を行ないます。環境変数は追加や削除を行なうことができるほか、 httpd プロセスから起動されるシェルからの値を渡すこともできます。このモジュールは既定で有効化されます。</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>mod_expires</systemitem></term>
     <listitem>
      <para><systemitem>mod_expires</systemitem> を使用すると、 <systemitem>Expires</systemitem> ヘッダを送信して、プロキシサーバやブラウザのキャッシュ機能に対して、どれだけの時間で文書の期限が切れるのかを指定することができるようになります。このモジュールは既定で有効化されます。</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>mod_http2</systemitem></term>
     <listitem>
      <para><systemitem>mod_http2</systemitem> を利用することで、 Apache は HTTP/2 プロトコルに対応するようになります。 <systemitem>VirtualHost</systemitem> 内で <literal>Protocols h2 http/1.1</literal> と指定することで有効化することができます。</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>mod_include</systemitem></term>
     <listitem>
      <para><systemitem>mod_include</systemitem> は Server Side Includes (SSI) と呼ばれる機能を提供するモジュールで、 HTML ページを動的に生成するための基本的な技術を提供します。このモジュールは既定で有効化されます。</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>mod_info</systemitem></term>
     <listitem>
      <para>http://localhost/server-info/ にアクセスすることで、サーバの設定概要を表示することができるようになるモジュールです。セキュリティ上の理由から、この URL に対するアクセスは常に制限しておくべきです。既定では <systemitem class="domainname">localhost</systemitem> からのみアクセスすることができます。また、 <systemitem>mod_info</systemitem> は <filename>/etc/apache2/mod_info.conf</filename> で設定されています。</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>mod_log_config</systemitem></term>
     <listitem>
      <para>このモジュールを使用することで、 Apache のログファイルに出力される内容を制御することができます。このモジュールは既定で有効化されます。</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>mod_mime</systemitem></term>
     <listitem>
      <para>このモジュールは、ファイル名の拡張子を利用することで、ファイルに対する正しい MIME ヘッダ (たとえば HTML 文書であれば <systemitem>text/html</systemitem>) を配信する仕組みを提供します。このモジュールは既定で有効化されます。</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>mod_negotiation</systemitem></term>
     <listitem>
      <para>コンテンツネゴシエーションを行なうために必要なモジュールです。詳しい説明は、 <link xlink:href="http://httpd.apache.org/docs/2.4/content-negotiation.html">http://httpd.apache.org/docs/2.4/content-negotiation.html</link> をお読みください。このモジュールは既定で有効化されます。</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>mod_rewrite</systemitem></term>
     <listitem>
      <para><systemitem>mod_alias</systemitem> と同じような機能を提供するモジュールですが、より多くの機能が追加され、より柔軟な設定ができるようになっています。 <systemitem>mod_rewrite</systemitem> を利用することで、複数のルールやリクエストヘッダをベースにして URL の転送を設定したりすることができます。</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>mod_setenvif</systemitem></term>
     <listitem>
      <para>クライアント側からのリクエストに応じて環境変数を設定するモジュールです。これにはたとえば、クライアントが送信したブラウザ文字列やクライアントの IP アドレスなどが含まれます。このモジュールは既定で有効化されます。</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>mod_spelling</systemitem></term>
     <listitem>
      <para><systemitem>mod_spelling</systemitem> は、大文字と小文字の違いなどの入力ミスを自動的に修正しようと試みるモジュールです。</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>mod_ssl</systemitem></term>
     <listitem>
      <para>ブラウザとクライアントとの間で、暗号化した接続を実現するモジュールです。詳しくは <xref linkend="sec.apache2.ssl"/> をお読みください。このモジュールは既定で有効化されます。</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>mod_status</systemitem></term>
     <listitem>
      <para>http://localhost/server-status/ にアクセスすることで、サーバの動作状況と性能情報を表示することができるようになるモジュールです。セキュリティ上の理由から、この URL に対するアクセスは常に制限しておくべきです。既定では <systemitem class="domainname">localhost</systemitem> からのみアクセスすることができます。また、 <systemitem>mod_status</systemitem> は <filename>/etc/apache2/mod_status.conf</filename> で設定されています。</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>mod_suexec</systemitem></term>
     <listitem>
      <para><systemitem>mod_suexec</systemitem> は、 CGI スクリプトを異なるユーザやグループで実行することができるモジュールです。このモジュールは既定で有効化されます。</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>mod_userdir</systemitem></term>
     <listitem>
      <para><filename>~<replaceable>ユーザ名</replaceable>/</filename> の形式で、ユーザ別のディレクトリを有効化するモジュールです。このモジュールを利用するには、 <systemitem>UserDir</systemitem> ディレクティブを設定しなければなりません。このモジュールは既定で有効化されます。</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 xml:id="sec.apache2.modules.mpm">
   <title>マルチプロセッシングモジュール (MPM)</title>
   <para>&productname; では、 Apache で利用することのできるマルチプロセッシングモジュールが 2 種類用意されています:</para>
   <itemizedlist mark="bullet" spacing="normal">
    <listitem>
     <para><xref linkend="sec.apache2.modules.mpm.prefork" xrefstyle="select:title"/></para>
    </listitem>
    <listitem>
     <para><xref linkend="sec.apache2.modules.mpm.worker" xrefstyle="select:title"/></para>
    </listitem>
   </itemizedlist>
   <sect3 xml:id="sec.apache2.modules.mpm.prefork">
    <title>prefork MPM</title>
    <para>prefork MPM はスレッドを使用しない、事前 fork 型の Web サーバです。 Apache バージョン 1.x に似た動作の Web サーバになります。このバージョンでは、それぞれのリクエストと処理を個別の子プロセスに分離して処理します。これにより、何らかの問題が発生しても、他のプロセスには影響を及ぼすことがなく、 Web サーバの機能停止を防ぐことができるようになっています。</para>
    <para>このようなプロセスベースの仕組みでは安定性がもたらされるものの、 worker MPM よりはより多くのシステム資源を消費してしまいます。また、 Unix ベースのオペレーティングシステムでは、 prefork MPM を既定の MPM としています。</para>
    <important>
     <title>本文書内での MPM について</title>
     <para>この文書内では、 Apache 内で prefork MPM を使用することを前提に説明しています。</para>
    </important>
   </sect3>
   <sect3 xml:id="sec.apache2.modules.mpm.worker">
    <title>worker MPM</title>
    <para>worker MPM はマルチスレッド型の Web サーバです。スレッドはプロセスよりもずっと <quote>軽量</quote> な仕組みであるため、より少ない資源消費が特長になります。この MPM では、子プロセスを起動する代わりに、それぞれのリクエストに対してスレッドを割り当てて処理を行ないます。また、場合によっては複数のプロセスを起動することもありますが、子プロセスも同様にマルチスレッドになります。このような仕組みにより、 prefork MPM よりずっと少ない資源で Apache を動作させることができます。</para>
    <para>worker MPM での最も大きな欠点は、その安定性です。何らかの理由でスレッド内のメモリが破壊されてしまうと、同じプロセスに属する全てのスレッドが影響を受けます。最も悪いケースでは、サーバ自身がクラッシュしてしまいます。特に、負荷の高い環境下で Common Gateway Interface (CGI) を使用した場合、システム資源との通信が失敗することによってサーバ内部エラーが発生することがあります。また、もう 1 つの欠点としては、全ての Apache モジュールがスレッド型の仕組みに対応しているというわけではない (スレッドセーフではない) というものがあります。これにより、 worker MPM を利用できない場合もあります。</para>
    <warning>
     <title>MPM と PHP の関係について</title>
     <para>PHP モジュールによっては、マルチスレッド環境での使用が安全ではない (スレッドセーフではない) ものがあります。そのため、 <systemitem>mod_php</systemitem> を使用する場合は、 Worker MPM を使用しないことを強くお勧めします。</para>
    </warning>
   </sect3>
  </sect2>

  <sect2 xml:id="sec.apache2.modules.external">
   <title>外部モジュール</title>
   <para>ここには、 &productname; に同梱されている全ての外部モジュールが一覧で示されています。それぞれのモジュールのドキュメンテーションについては、それぞれのディレクトリをご覧ください。</para>
   <variablelist>
    <varlistentry>
     <term><systemitem>mod_apparmor</systemitem></term>
     <listitem>
      <para><systemitem>mod_php5</systemitem> などで処理される CGI スクリプトに対して、 &aa; の制約を適用する Apache 向けのモジュールです。</para>
      <simplelist>
       <member>パッケージ名: <systemitem>apache2-mod_apparmor</systemitem></member>
       <member>詳しい情報: <xref linkend="part.apparmor"/></member>
      </simplelist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>mod_php5</systemitem></term>
     <listitem>
      <para>PHP はサーバサイドスクリプトで複数プラットフォームに対応する HTML 組み込み型のスクリプト言語です。</para>
      <simplelist>
       <member>パッケージ名: <systemitem>apache2-mod_php5</systemitem></member>
       <member>設定ファイル: <filename>/etc/apache2/conf.d/php5.conf</filename></member>
       <member>詳しい情報: <filename>/usr/share/doc/packages/apache2-mod_php5</filename></member>
      </simplelist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>mod_python</systemitem></term>
     <listitem>
      <para><systemitem>mod_python</systemitem> は Apache HTTP サーバ内に Python の機能を組み込むもので、性能を大きく向上させることができるほか、 Web ベースのアプリケーションに柔軟性を与えます。</para>
      <simplelist>
       <member>パッケージ名: <systemitem>apache2-mod_python</systemitem></member>
       <member>詳しい情報: <filename>/usr/share/doc/packages/apache2-mod_python</filename></member>
      </simplelist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>mod_security</systemitem></term>
     <listitem>
      <para><systemitem>mod_security</systemitem> は Web アプリケーションファイアウオールで、様々な範囲の攻撃から Web アプリケーションを保護します。 HTTP のトラフィック監視やリアルタイム分析に使用することもできます。</para>
      <simplelist>
       <member>パッケージ名: <systemitem>apache2-mod_security2</systemitem></member>
       <member>設定ファイル: <filename>/etc/apache2/conf.d/mod_security2.conf</filename></member>
       <member>詳しい情報: <filename>/usr/share/doc/packages/apache2-mod_security2</filename></member>
       <member>ドキュメンテーション: <link xlink:href="http://modsecurity.org/documentation/"/></member>
      </simplelist>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 xml:id="sec.apache2.modules.building_modules">
   <title>コンパイル</title>
   <para>知識のあるユーザであれば、 Apache に対して独自のモジュールを作成して拡張することができます。 Apache 向けのモジュールを開発したり、サードパーティ製のモジュールをコンパイルしたりしたい場合は、 <systemitem>apache2-devel</systemitem> パッケージをインストールして、提供される開発ツールをお使いください。 <systemitem>apache2-devel</systemitem> には <command>apxs2</command> ツールが含まれていますが、これは Apache 向けのモジュールをコンパイルする際に使用するツールです。</para>
   <para><command>apxs2</command> は、ソースコードからモジュールをコンパイルして、インストールする機能を提供します (設定ファイルへの必要な変更を含みます) 。コンパイルを行なうと、 <emphasis>動的共有オブジェクト</emphasis> (Dynamic Shared Objects; DSO) として作成され、 Apache の起動時に読み込みができるようになります。</para>
   <para><command>apxs2</command> バイナリは、 <filename>/usr/sbin</filename> ディレクトリ内に配置されます:</para>
   <itemizedlist mark="bullet" spacing="normal">
    <listitem>
     <para><filename>/usr/sbin/apxs2</filename> は、どの MPM でも動作する拡張モジュールをコンパイルするためのツールです。インストールを行なうと、そのモジュールは <filename>/usr/lib64/apache2</filename> 内にインストールされます。</para>
    </listitem>
    <listitem>
     <para><filename>/usr/sbin/apxs2-prefork</filename> は、 prefork MPM で動作する拡張モジュールをコンパイルするためのツールです。インストールを行なうと、そのモジュールは <filename>/usr/lib64/apache2-prefork</filename> 内にインストールされます。</para>
    </listitem>
    <listitem>
     <para><filename>/usr/sbin/apxs2-worker</filename> は、 worker MPM で動作する拡張モジュールをコンパイルするためのツールです。インストールを行なうと、そのモジュールは <filename>/usr/lib64/apache2-worker</filename> 内にインストールされます。</para>
    </listitem>
   </itemizedlist>
   <para>ソースコードからモジュールをコンパイルしてインストールし、有効化するには、下記のコマンドを実行します:</para>
<screen>&prompt.sudo;cd /<replaceable>モジュールのソースコードのパス</replaceable>
&prompt.sudo;apxs2 -cia <replaceable>モジュール名</replaceable>.c</screen>
   <para>ここで、 <option>-c</option> はモジュールのコンパイルを、 <option>-i</option> はインストールを、 <option>-a</option> は有効化をそれぞれ行なうオプションです。 <command>apxs2</command> に対するその他のオプションについては、 <systemitem>apxs2(1)</systemitem> のマニュアルページをお読みください。</para>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.apache2.cgi">
  <title>CGI スクリプトの有効化</title>

  <para>Apache の汎用ゲートウエイインターフェイス (Common Gateway Interface (CGI)) を利用することで、 CGI と呼ばれるプログラムやスクリプトを実行して動的なコンテンツを生成することができます。 CGI スクリプトは任意のプログラミング言語を利用することができます。通常は PHP などのスクリプト言語を使用します。</para>

  <para>CGI スクリプトが生成したコンテンツを Apache から配信できるようにするには、 <systemitem>mod_cgi</systemitem> を有効化する必要があります。また、 <systemitem>mod_alias</systemitem> もあわせて有効化する必要があります。いずれのモジュールとも既定で有効化されています。モジュールの有効化について、詳しくは <xref linkend="sec.apache2.modules.activating"/> をお読みください。</para>

  <warning>
   <title>CGI セキュリティ</title>
   <para>サーバ内で CGI スクリプトを実行できるように設定すると、潜在的なセキュリティホールとなる可能性があります。詳しくは <xref linkend="sec.apache2.security"/> をお読みください。</para>
  </warning>

  <sect2 xml:id="sec.apache2.cgi.configuration">
   <title>Apache の設定</title>
   <para>&productname; では、 CGI スクリプトの実行は <filename>/srv/www/cgi-bin/</filename> ディレクトリ内でのみ許可されるように設定されています。この場所は CGI スクリプトを実行する場所として設定されているディレクトリでもあります。仮想ホストの設定を作成している (詳しくは <xref linkend="sec.apache2.configuration.manually.vhost"/>) 場合で、仮想ホスト固有のディレクトリ内で CGI スクリプトを実行したい場合は、そのディレクトリでの CGI スクリプトの実行を許可するよう設定しなければなりません。</para>
   <example xml:id="ex.apache2.cgi.configuration">
    <title>VirtualHost CGI 設定</title>
<screen>ScriptAlias /cgi-bin/ "/srv/www/&wwwname;/cgi-bin/"<co xml:id="co.apache2.cgi.script_alias"/>

&lt;Directory "/srv/www/&wwwname;/cgi-bin/"&gt;
 Options +ExecCGI<co xml:id="co.apache2.cgi.options"/>
 AddHandler cgi-script .cgi .pl<co xml:id="co.apache2.cgi.handler"/>
 Require all granted<co xml:id="co.apache2.cgi.order"/>
&lt;/Directory&gt;</screen>
    <calloutlist>
     <callout arearefs="co.apache2.cgi.script_alias">
      <para>このディレクトリ内にある全てのファイルを、 CGI スクリプトとして実行するよう指定しています。</para>
     </callout>
     <callout arearefs="co.apache2.cgi.options">
      <para>CGI スクリプトの実行を有効化しています。</para>
     </callout>
     <callout arearefs="co.apache2.cgi.handler">
      <para>.pl と .cgi の拡張子を持つファイルを、 CGI スクリプトとして扱うよう指定しています。こちらは必要に応じて変更してください。</para>
     </callout>
     <callout arearefs="co.apache2.cgi.order">
      <para><systemitem>Require</systemitem> ディレクティブは、既定のアクセス状態を制御するためのディレクティブです。この場合、指定したディレクトリへのアクセスは制限無く許可されます。認証と認可について、詳しくは <link xlink:href="http://httpd.apache.org/docs/2.4/howto/auth.html"/> をお読みください。</para>
     </callout>
    </calloutlist>
   </example>
  </sect2>

  <sect2 xml:id="sec.apache2.cgi.example_script">
   <title>サンプルスクリプトの実行</title>
   <para>CGI のプログラミングは "通常の" プログラミングとは異なり、 <literal>Content-type: text/html</literal> のような MIME タイプヘッダなどを冒頭に送信しなければなりません。このヘッダはクライアントに送信されるもので、どのような種類のコンテンツを送信しているのかを表明しています。また、スクリプトが送信するコンテンツは、クライアント側 (たとえば Web ブラウザ) が解釈できるものでなければなりません。通常は HTML などですが、純粋なテキストや画像などでもかまいません。</para>
   <para><filename>/usr/share/doc/packages/apache2/test-cgi</filename> には、シンプルなテスト用スクリプトが用意されています。これは Apache パッケージの一部として提供されているもので、純粋なテキスト形式でいくつかの環境変数を出力するものです。このスクリプトを <filename>/srv/www/cgi-bin/</filename> にコピーするか、もしくは仮想ホスト ( <filename>/srv/www/&wwwname;/cgi-bin/</filename> ) などにコピーして、 <filename>test.cgi</filename> のような名前に変更してください。また、ファイルの冒頭に <literal>#!/bin/sh</literal> を追加してください。</para>
   <para>また、 Web サーバからアクセスできるようにするには、所有者が <systemitem class="username">root</systemitem> である必要もあります。詳しくは <xref linkend="sec.apache2.security"/> をお読みください。なお、 Web サーバは異なるユーザとして動作する仕組みであるため、 CGI スクリプトは全てのユーザが実行でき、かつ読み込みできるものでなければなりません。必要なアクセス権を適用するには、 CGI のディレクトリに移動して <command>chmod 755 test.cgi</command> を実行してください。</para>
   <para>これで <literal>http://localhost/cgi-bin/test.cgi</literal> または <literal>http://&wwwname;/cgi-bin/test.cgi</literal> で CGI スクリプトを実行することができます。 <quote>CGI/1.0 test script report</quote> のような画面が表示されるはずです。</para>
  </sect2>

  <sect2 xml:id="sec.apache2.cgi.troubleshooting">
   <title>CGI トラブルシューティング</title>
   <para>テストプログラムの出力が正しく表示されず、エラーメッセージが表示されてしまった場合は、下記をご確認ください:</para>
   <itemizedlist mark="bullet" spacing="normal">
    <title>CGI トラブルシューティング</title>
    <listitem>
     <para><emphasis>設定の変更後、設定を反映させるために再読み込みを実施しましたか？</emphasis> 実施していない場合は、 <command>systemctl reload apache2</command> で再読み込みを実施してください。</para>
    </listitem>
    <listitem>
     <para><emphasis>独自の CGI ディレクトリを設定している場合は、その設定が適切に行なわれていますか？</emphasis> 何か不安な点がある場合は、既定の CGI ディレクトリである <filename>/srv/www/cgi-bin/</filename> にスクリプトをコピーして、 <literal>http://localhost/cgi-bin/test.cgi</literal> にアクセスしてみてください。</para>
    </listitem>
    <listitem>
     <para><emphasis>ファイルのアクセス権は正しく設定されていますか？</emphasis> CGI のディレクトリに移動して、 <command>ls -l test.cgi</command> を実行してください。出力の冒頭は下記のようになっているはずです:</para>
<screen>-rwxr-xr-x  1 root root</screen>
    </listitem>
    <listitem>
     <para>スクリプトにプログラミングエラーが無いことをご確認ください。 <filename>test.cgi</filename> を変更せずにそのまま使用している場合は問題なく動作するはずですが、独自に作成したプログラムを使用している場合は、プログラミングに問題がないことをよく確認する必要があります。</para>
    </listitem>
   </itemizedlist>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.apache2.ssl">
  <title>SSL を利用した暗号化機能付き Web サーバの設定</title>

  <para>クレジットカード情報などの機密データを Web サーバとクライアントとの間でやりとりするにあたっては、認証機能付きの暗号化接続を行なって機密を保持する必要があります。 <systemitem>mod_ssl</systemitem> では Secure Sockets Layer (SSL) や Transport Layer Security (TLS) を利用して、クライアントと Web サーバとの間の HTTP 通信に対して強力な暗号化機能を提供します。つまり、 TLS/SSL を利用することで Web サーバとクライアントの間の通信を盗聴できなくすることになります。もちろんデータの整合性についても確認が行なわれますし、クライアントとサーバはお互いに認証することができます。</para>

  <para>このような目的から、サーバは要求された URL に応答する前に、サーバ自身の正しい識別情報を示す SSL 証明書を送信します。これによりクライアント側は、通信している相手が間違いのないものであることを確認できることになります。これに加えて、証明書は暗号化接続を生成することができますので、クライアントとサーバとの間でやり取りされる情報が、純粋なテキストのように漏洩することがなくなります。</para>

  <para><systemitem>mod_ssl</systemitem> は TLS/SSL プロトコルを直接実装しているわけではありません。その代わりに、 Apache と SSL ライブラリとの仲介インターフェイスとして動作します。 &productname; では OpenSSL ライブラリを使用します。 OpenSSL は、 Apache をインストールすると自動的にインストールされます。</para>

  <para>Apache で <systemitem>mod_ssl</systemitem> を利用すると、目に見える違いとしては URL が <literal>http://</literal> ではなく <literal>https://</literal> になります。</para>

  <sect2 xml:id="sec.apache2.ssl.certificate">
   <title>SSL 証明書の作成</title>
   <para>Web サーバで TLS/SSL を使用するには、まず SSL 証明書を作成する必要があります。この証明書は Web サーバとクライアントとの間で認証を行なうのに必要なもので、クライアントがサーバを明確に識別することができます。証明書の正当性を確保するには、各ユーザが信頼する団体で署名してもらわなければなりません。</para>
   <para>作成できる証明書には、 3 つの種類があります。 1 つ目は <quote>ダミー</quote> の証明書で、テスト用にのみ使用することができます。 2 つ目は自己署名証明書と呼ばれるもので、あなた自身を信頼する特定範囲のユーザのみ利用できるものです。 3 つ目は公的な証明書で、証明機関 (Certificate Authority (CA)) と呼ばれる独立した第三者機関が署名する正式な証明書です。</para>
   <para>証明書の作成は 2 段階の手順から構成されています。最初に証明機関の機密鍵を作成し、次にその鍵でサーバ証明書に署名を行ないます。</para>
   <tip>
    <title>さらなる情報</title>
    <para>TLS/SSL の考え方や定義についての詳細は、 <link xlink:href="http://httpd.apache.org/docs/2.4/ssl/ssl_intro.html">http://httpd.apache.org/docs/2.4/ssl/ssl_intro.html</link> をお読みください。</para>
   </tip>
   <sect3 xml:id="sec.apache2.ssl.certificate.dummy">
    <title><quote>ダミー</quote> の証明書の作成</title>
    <para>ダミーの証明書を作成するには、 <command>/usr/bin/gensslcert</command> を実行します。これを実行すると、下記に示すファイルを作成もしくは上書きします。なお、 <command>gensslcert</command> のオプションスイッチを指定することで、証明書の詳細を調整することができます。詳しくは <command>/usr/bin/gensslcert </command> <option>-h</option> を実行してください。</para>
    <itemizedlist mark="bullet" spacing="normal">
     <listitem>
      <para><filename>/etc/apache2/ssl.crt/ca.crt</filename></para>
     </listitem>
     <listitem>
      <para><filename>/etc/apache2/ssl.crt/server.crt</filename></para>
     </listitem>
     <listitem>
      <para><filename>/etc/apache2/ssl.key/server.key</filename></para>
     </listitem>
     <listitem>
      <para><filename>/etc/apache2/ssl.csr/server.csr</filename></para>
     </listitem>
    </itemizedlist>
    <para><filename>ca.crt</filename> のコピーを <filename>/srv/www/htdocs/CA.crt</filename> に配置して、ダウンロードできるようにしておくとよいでしょう。</para>
    <important>
     <title>テスト用途のみでの使用について</title>
     <para>ダミーの証明書は本番環境で使用すべきではありません。テスト目的にのみお使いください。</para>
    </important>
   </sect3>
   <sect3 xml:id="sec.apache2.ssl.certificate.custom">
    <title>自己署名証明書の作成</title>
    <para>イントラネット環境や特定の範囲のユーザのみ公開する Web サーバを構築する際は、自分自身が証明機関 (CA) になって証明書に署名を付与し、使用すれば十分な場合があります。ただし、公的な証明書ではなく、 Web ブラウザが証明書を識別することができないことから、ユーザがアクセスすると <quote>安全な接続ではありません</quote> のような警告メッセージが表示されることに注意してください。</para>
    <important>
     <title>自己署名証明書について</title>
     <para>自己署名証明書は、あなた自身を証明機関として信頼してくれる特定の範囲のユーザに対して提供する Web サーバにのみお使いください。たとえば一般向けの販売サイトなどでは、このような証明書を使用しないことをお勧めします。</para>
    </important>
    <para>まずは証明書署名要求 (Certificate Signing Request (CSR)) を生成します。この作業では <command>openssl</command> を利用し、 <literal>PEM</literal> 形式で作成を行ないます。また、この手順ではパスフレーズのほか、いくつかの質問に解凍する必要があります。パスフレーズは今後入力を求められることになりますので、忘れずに記憶しておいてください。</para>
<screen>&prompt.sudo;openssl req -new &gt; new.cert.csr
Generating a 1024 bit RSA private key
..++++++
.........++++++
writing new private key to 'privkey.pem'
Enter PEM pass phrase:<co xml:id="co.ssl.self.pass1"/>
Verifying - Enter PEM pass phrase:<co xml:id="co.ssl.self.pass2"/>
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [AU]:<co xml:id="co.ssl.self.country"/>
State or Province Name (full name) [Some-State]:<co xml:id="co.ssl.self.state"/>
Locality Name (eg, city) []:<co xml:id="co.ssl.self.city"/>
Organization Name (eg, company) [Internet Widgits Pty Ltd]:<co xml:id="co.ssl.self.org"/>
Organizational Unit Name (eg, section) []:<co xml:id="co.ssl.self.uname"/>
Common Name (for example server FQDN, or YOUR name) []:<co xml:id="co.ssl.self.cname"/>
Email Address []:<co xml:id="co.ssl.self.email"/>

Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []:<co xml:id="co.ssl.self.challenge"/>
An optional company name []:<co xml:id="co.ssl.self.optional"/></screen>
    <calloutlist>
     <callout arearefs="co.ssl.self.pass1">
      <para>パスフレーズを入力します。</para>
     </callout>
     <callout arearefs="co.ssl.self.pass2">
      <para>再度パスフレーズを入力します (パスフレーズは忘れてはなりません) 。</para>
     </callout>
     <callout arearefs="co.ssl.self.country">
      <para>2 文字の国コードを入力します。日本であれば <literal>JP</literal> を入力します。</para>
     </callout>
     <callout arearefs="co.ssl.self.state">
      <para>通常は州名を入力します。<!-- NOTE: Japanese content --> 日本の場合は都道府県名を一般に入力します。 <!-- end --></para>
     </callout>
     <callout arearefs="co.ssl.self.city">
      <para>市区町村名を入力します。たとえば <literal>Chiyoda-ku</literal> のように入力します。</para>
     </callout>
     <callout arearefs="co.ssl.self.org">
      <para>所属する団体名を入力します。</para>
     </callout>
     <callout arearefs="co.ssl.self.uname">
      <para>組織単位を入力します。組織単位がない場合は、何も入力しなくてかまいません。</para>
     </callout>
     <callout arearefs="co.ssl.self.cname">
      <para>サーバのドメイン名、もしくはあなた自身のフルネームを入力します。</para>
     </callout>
     <callout arearefs="co.ssl.self.email">
      <para>電子メールアドレスを入力します。</para>
     </callout>
     <callout arearefs="co.ssl.self.challenge">
      <para>必要に応じてチャレンジパスワードを入力します。ここで何らかのパスワードを指定した場合は、 Apache Web サーバを再起動するたびに入力を求められます。</para>
     </callout>
     <callout arearefs="co.ssl.self.optional">
      <para>必要であれば企業名を入力します。不要であれば何も入力しなくてかまいません。</para>
     </callout>
    </calloutlist>
    <para>これで証明書を生成できるようになります。再度 <command>openssl</command> を使用して、既定の <literal>PEM</literal> 形式で証明書を生成します。</para>
    <procedure>
     <title>証明書の生成</title>
     <step>
      <para>機密鍵を <filename>new.cert.key</filename> にエクスポートします。証明書署名要求 (Certificate Signing Request; CSR) でパスフレーズを入力している場合は、ここで入力を求められます。</para>
<screen>&prompt.sudo;openssl rsa -in privkey.pem -out new.cert.key</screen>
     </step>
     <step>
      <para>署名要求で入力した情報に従って証明書の公開部分を生成します。 <option>-days</option> オプションは、証明書の期限が切れるまでの日数を指定します。なお、期限切れになる前でも、証明書を取り消したり新しいものに置き換えたりすることができます。</para>
<screen>&prompt.sudo;openssl x509 -in new.cert.csr -out new.cert.cert -req \
-signkey new.cert.key -days 365</screen>
     </step>
     <step>
      <para>生成された証明書ファイルを、 Apache から読み取ることのできるディレクトリにコピーします。なお、機密鍵である <filename>/etc/apache2/ssl.key/server.key</filename> ファイルは全てのユーザが読み込めるようにしてはなりませんが、公開鍵である <filename>/etc/apache2/ssl.crt/server.crt</filename> については、全てのユーザが読み込めるようにしておく必要があります。</para>
<screen>&prompt.sudo;cp new.cert.cert /etc/apache2/ssl.crt/server.crt
&prompt.sudo;cp new.cert.key /etc/apache2/ssl.key/server.key</screen>
     </step>
    </procedure>
    <tip>
     <title>証明書の公開先について</title>
     <para>最後に証明書ファイル <filename>/etc/apache2/ssl.crt/server.crt</filename> をユーザからアクセスできる場所にコピーして、各ユーザの Web ブラウザ内に取り込んで信頼してもらう作業が必要となります。この作業を実施しないと、ブラウザ側では未知の証明機関が発行した証明書であるものとして扱われてしまい、エラーまたは警告が表示されるようになってしまいます。</para>
    </tip>
   </sect3>
   <sect3 xml:id="sec.apache2.ssl.certificate.official">
    <title>公的に署名された証明書の取得</title>
    <para>一般的に利用可能な証明書を発行する機関は様々あります。証明書を公的に信頼されている機関に署名してもらうことで、 Web サーバ自身を完全に信頼してもらうことができるようになります。また、一般的な SSL/TLS 対応のブラウザであれば、公的な証明機関の証明書を保持していますので、ここから正当性を確認することができます。一般的に使用される証明機関 (CA) の一覧については、 <link xlink:href="https://en.wikipedia.org/wiki/Certificate_authority#Providers"/> などをご覧ください。</para>
    <para>公的に証明された証明書を取得するにあたっては、証明書そのものを CA に送信する必要はありません。その代わりに、証明書署名要求 (Certificate Signing Request; CSR) <!-- 2015-08-24, tbazant: replacing CA.sh with openssl (http://doccomments.provo.novell.com/comments/28367) (CSR). To create a CSR, call the script <command>/usr/share/ssl/misc/CA.sh -newreq</command>. --> を送信します。 CSR を作成するには、下記のコマンドを実行します:</para>
<screen>&prompt.user;openssl req -new -newkey rsa:2048 -nodes -keyout newkey.pem -out newreq.pem</screen>
    <para><!-- First the script asks for a password with which the CSR should be encrypted. --> ここでは識別名 (Distinguished Name) の入力を求められるほか、国コードや組織名などのいくつかの質問に回答する必要があります。ここで入力した内容は証明書内に記載されるほか、証明機関が内容をチェックすることもあります。なお、全ての質問に回答する必要はありません。不要であると判断した項目に対しては、 <quote>.</quote> とだけ入力して先に進めてください。<!-- ??? Common name is the name of the CA itself&mdash;choose a significant name, such as <replaceable>My company</replaceable> CA. Last, a challenge password and an alternative company name must be entered. --></para>
    <para>作成した CSR は、スクリプトを実行したディレクトリ内に出力されます。ファイル名は <filename>newreq.pem</filename> という名前になります。</para>
   </sect3>
  </sect2>

  <sect2 xml:id="sec.apache2.ssl.configuration">
   <title>SSL を利用する場合の Apache の設定</title>
   <para>Web サーバで TLS/SSL を使用する場合、既定のポートは 443 が割り当てられています。 TLS/SSL のない <quote>通常の</quote> Apache はポート 80 で、 TLS/SSL を使用する場合の Apache は 443 を使用しますが、両方のサービスを単一の Apache インスタンスで賄うことができます。また、それぞれに対して別々の仮想ホストを設定して、提供する内容やサービスなどを変更したりすることもあります。</para>
   <important>
    <title>ファイアウオールの設定</title>
    <para>なお、 Apache で SSL (ポート 443) を使用するにあたっては、ファイアウオールでポートを開くことを忘れずに実施してください。この作業は &firewalld; で行ないます。詳しくは <xref linkend="sec.security.firewall.firewalld.cmd"/> をお読みください。</para>
   </important>
   <para>SSL モジュールは、サーバ全体の設定の中で既定で有効化されています。有効化されていない場合は、 <command>a2enmod ssl</command> で有効化することができます。また、 SSL を有効化する場合は、フラグ <quote>SSL</quote> を設定する必要があります。フラグを設定するには、 <command>a2enflag SSL</command> (大文字であることに注意してください) を実行します。また、サーバ証明書を暗号化している場合は、 <filename>/etc/sysconfig/apache2</filename> 内の <systemitem>APACHE_TIMEOUT</systemitem> の値を十分に大きな値にして、 Apache 開始時のパスワード入力に十分な時間が確保されるようにしてください。最後にサーバを再起動すると、変更を反映させることができます。再読み込みでは不十分ですので、あらかじめご注意ください。</para>
   <para>仮想ホストの設定では、 <filename>/etc/apache2/vhosts.d/vhost-ssl.template</filename> の雛形に従って、いくつかの SSL 固有のディレクティブを追加する必要があります。雛形内には詳しく説明がありますので、こちらをお読みください。また、仮想ホストの設定についての一般的な情報は、 <xref linkend="sec.apache2.configuration.manually.vhost"/> をお読みください。</para>
   <para>初めて SSL を設定する場合は、雛形を <filename>/etc/apache2/vhosts.d/<replaceable>仮想ホスト名</replaceable>.conf</filename> にコピーして、このファイルを編集していってください。それぞれ下記のディレクティブ部分を調整すれば、サーバを開始することができます:</para>
   <itemizedlist mark="bullet" spacing="normal">
    <listitem>
     <para><systemitem>DocumentRoot</systemitem></para>
    </listitem>
    <listitem>
     <para><systemitem>ServerName</systemitem></para>
    </listitem>
    <listitem>
     <para><systemitem>ServerAdmin</systemitem></para>
    </listitem>
    <listitem>
     <para><systemitem>ErrorLog</systemitem></para>
    </listitem>
    <listitem>
     <para><systemitem>TransferLog</systemitem></para>
    </listitem>
   </itemizedlist>
   <sect3 xml:id="sec.apache2.ssl.configuration.name-based">
    <title>名前ベースの仮想ホストと SSL の関係</title>
    <para>既定では、 1 つの IP アドレスしか設定されていないサーバの場合、 SSL が有効化された仮想ホストを複数実行することはできません。名前ベースの仮想ホストでは、 Apache 側に仮想ホストのホスト名を設定し、 Apache がリクエストの内容を読み込んで仮想ホストを判別しますが、 SSL 接続の処理は Apache がリクエストを処理するよりも前に行なわれるため、 1 つの IP アドレスに対して SSL の設定を複数持たせることができず、これによって常に既定の仮想ホストのみが使われる結果になってしまいます。これにより、証明書に書かれているサーバ名と、実際にアクセスしているサーバ名が異なる、という警告メッセージをユーザが受け取る結果にもなってしまいます。</para>
    <para>そのため、 &productname; では、サーバ名表示 (Server Name Indication (SNI)) と呼ばれる SSL プロトコルの拡張に対応するようになっています。これは、 SSL の処理内で仮想ホストのドメイン名を送信するための仕組みで、これによってサーバは、 SSL の処理を行なう時点で仮想ホストの判別ができるようになります。そのため、サーバ側は早期に適切な仮想ホストに <quote>切り替える</quote> ことができるようなり、ブラウザ側にも正しい証明書を配信できるようになります。</para>
    <para>SNI は &productname; では既定で有効化されています。 SSL を利用して名前ベースの仮想ホストを設定するには、 <xref linkend="sec.apache2.configuration.manually.vhost.named_vhosts"/> の手順に従って設定を行なってください (ただし、 SSL を利用するには、ポート <literal>80</literal> ではなくポート <literal>443</literal> を使用するように設定する必要があります) 。</para>
    <important>
     <title>SNI 対応ブラウザについて</title>
     <para>SNI はクライアント側でも対応している必要がありますが、現時点では特定の古いブラウザを除いて、ほとんどのブラウザで対応するようになっています。詳しくは <link xlink:href="https://ja.wikipedia.org/wiki/Server_Name_Indication#%E5%AF%BE%E5%BF%9C%E7%8A%B6%E6%B3%81"/> をお読みください。</para>
     <para>SNI 対応のブラウザに対する処理を設定するには、 <systemitem>SSLStrictSNIVHostCheck</systemitem> というディレクティブを設定します。この値をサーバ全体の設定で <literal>on</literal> にすると、全ての仮想ホストに対して SNI 非対応のブラウザからのアクセスを拒否するようになります。 <systemitem>VirtualHost</systemitem> ディレクティブ内で <literal>on</literal> に設定すると、特定の仮想ホストのみが拒否されるようになります。</para>
     <para>サーバ全体の設定で <literal>off</literal> に設定した場合、サーバ側は SNI への対応を全く行なわなくなります。この場合、 SSL のリクエストが届くと、設定された <emphasis>最初の</emphasis> 仮想ホスト (ポート: 443) にアクセスがあったものとして扱われます。</para>
    </important>
   </sect3>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.apache2.multiple_instances">
  <title>同一サーバ内での複数 Apache インスタンスの起動</title>

  <para>&productnamereg; <phrase os="sles;sled">12 SP1</phrase> <phrase os="osuse">42.1</phrase> 以降のバージョンでは、同一のサーバ内で複数の Apache インスタンスを動作させることができます。これは複数の仮想ホストを動作させるのに比べて、幾分かの利点があります (詳しくは <xref linkend="sec.apache2.configuration.manually.vhost"/> をお読みください) 。</para>

  <itemizedlist>
   <listitem>
    <para>何らかの理由で仮想ホストを無効化したい場合、通常であれば Web サーバの設定を変更して、その変更を反映させるために再起動を行なう必要があります。</para>
   </listitem>
   <listitem>
    <para>いずれかの仮想ホストで何らかの障害が発生した場合、全ての仮想ホストを再起動する必要があります。</para>
   </listitem>
  </itemizedlist>

  <para>既定の Apache インスタンスについては、通常通り開始することができます:</para>

<screen>&prompt.sudo;systemctl start apache2</screen>

  <para>上記を実行すると、既定の <filename>/etc/sysconfig/apache2</filename> ファイルを読み込みます。このファイルが存在しない場合や、 <systemitem>APACHE_HTTPD_CONF</systemitem> 変数が設定されていない場合は、 <filename>/etc/apache2/httpd.conf</filename> を読み込みます。</para>

  <para>もう 1 つの Apache インスタンスを開始したい場合は、下記のように実行します:</para>

<screen>&prompt.sudo;systemctl start apache2@<replaceable>インスタンス名</replaceable></screen>

  <para>たとえば、下記のようになります:</para>

<screen>&prompt.sudo;systemctl start apache2@example_web.org</screen>

  <para>既定では、このインスタンスは <filename>/etc/apache2@example_web.org/httpd.conf</filename> というファイル名の設定ファイルを読み込みます。このファイル名の指定は、 <filename>/etc/sysconfig/apache2@example_web.org</filename> というファイル名の <systemitem>APACHE_HTTPD_CONF</systemitem> の設定で変更することができます。</para>

  <para>Apache の追加インスタンスを設定するには、下記の手順を実施します。なお、全てのコマンドを &rootuser; で実行することに注意してください。</para>

  <procedure>
   <title>追加の Apache インスタンスの設定</title>
   <step>
    <para>まずは新しい設定ファイルを、 <filename>/etc/sysconfig/apache2</filename> にあるものをベースにして作成します。たとえば <filename>/etc/sysconfig/apache2@example_web.org</filename> を作成します:</para>
<screen>&prompt.sudo;cp /etc/sysconfig/apache2 /etc/sysconfig/apache2@example_web.org</screen>
   </step>
   <step>
    <para><filename>/etc/sysconfig/apache2@example_web.org</filename> ファイルを編集し、下記の変数を修正します:</para>
<screen>APACHE_HTTPD_CONF</screen>
    <para>上記を、下記のように変更します:</para>
<screen>APACHE_HTTPD_CONF="/etc/apache2/httpd@example_web.org.conf"</screen>
   </step>
   <step>
    <para>次に <filename>/etc/apache2/httpd.conf</filename> ファイルをベースにして、 <filename>/etc/apache2/httpd@example_web.org.conf</filename> ファイルを作成します。</para>
<screen>&prompt.sudo;cp /etc/apache2/httpd.conf /etc/apache2/httpd@example_web.org.conf</screen>
   </step>
   <step>
    <para><filename>/etc/apache2/httpd@example_web.org.conf</filename> ファイルを編集し、下記を変更します:</para>
<screen>Include /etc/apache2/listen.conf</screen>
    <para>上記を、下記のように変更します:</para>
<screen>Include /etc/apache2/listen@example_web.org.conf</screen>
    <para>その他のディレクティブを確認して、必要であれば変更します。おそらくは下記のディレクティブを変更する必要があるものと思われます:</para>
<screen>Include /etc/apache2/global.conf</screen>
    <para>上記を変更して、新しいインスタンス用に <filename>global@example_web.org.conf</filename> ファイルを作成します。また、下記についても変更しておくことをお勧めします:</para>
<screen>ErrorLog /var/log/apache2/error_log</screen>
    <para>上記を、下記のように変更します:</para>
<screen>ErrorLog /var/log/apache2/error@example_web.org_log</screen>
    <para>これにより、各インスタンスのログを別々にすることができます。</para>
   </step>
   <step>
    <para>さらに <filename>/etc/apache2/listen.conf</filename> をベースにして、 <filename>/etc/apache2/listen@example_web.org.conf</filename> ファイルを作成します。</para>
<screen>&prompt.sudo;cp /etc/apache2/listen.conf /etc/apache2/listen@example_web.org.conf</screen>
   </step>
   <step>
    <para><filename>/etc/apache2/listen@example_web.org.conf</filename> を編集して、下記を変更します:</para>
<screen>Listen 80</screen>
    <para>上記を新しいインスタンスのポート番号に変更します。たとえば 82 であれば、下記のようになります:</para>
<screen>Listen 82</screen>
    <para>新しい Apache インスタンスで SSL/TLS を利用する場合 (詳しくは <xref linkend="sec.apache2.ssl"/> をお読みください) は、下記の行についても変更する必要があります:</para>
<screen>Listen 443</screen>
    <para>上記を、たとえば下記のように変更します:</para>
<screen>Listen 445</screen>
   </step>
   <step>
    <para>あとは新しい Apache インスタンスを開始します:</para>
<screen>&prompt.sudo;systemctl start apache2@example_web.org</screen>
   </step>
   <step>
    <para>最後にお使いの Web ブラウザから、サーバが動作していることを確認します。ここまでの設定を行なっていれば、 <literal>http://server_name:82</literal> でアクセスできるはずです。なお、新しいインスタンスで個別のエラーログを出力するように設定している場合は、下記のようにして確認することができます:</para>
<screen>&prompt.sudo;tail -f /var/log/apache2/error@example_web.org_log</screen>
   </step>
  </procedure>

  <para>同一のサーバで複数の Apache インスタンスを動作させるにあたっては、下記の点を考慮する必要があります:</para>

  <itemizedlist>
   <listitem>
    <para><filename>/etc/sysconfig/apache2@<replaceable>インスタンス名</replaceable></filename> ファイルでは、 <filename>/etc/sysconfig/apache2</filename> と同じ値を設定することができます。これにより、モジュールの読み込みや MPM の設定を同じにすることができます。</para>
   </listitem>
   <listitem>
    <para>また、新しい Apache インスタンスは、既定の Apache インスタンスが動作していなくても開始することができます。</para>
   </listitem>
   <listitem>
    <para>Apache のヘルパーユーティリティである <command>a2enmod</command> , <command>a2dismod</command> , <command>apachectl</command> は、 <systemitem>HTTPD_INSTANCE</systemitem> 環境変数を指定していない場合、いずれも既定の Apache インスタンスに対して操作を行ないます。インスタンス名を指定する場合は、たとえば下記のようにして実行します:</para>
<screen>&prompt.sudo;export HTTPD_INSTANCE=example_web.org
&prompt.sudo;a2enmod access_compat
&prompt.sudo;a2enmod status
&prompt.sudo;apachectl start</screen>
    <para>上記を実行すると、 <filename>/etc/sysconfig/apache2@example_web.org</filename> にある <systemitem>APACHE_MODULES</systemitem> の値に対して、 <systemitem>access_compat</systemitem> と <systemitem>status</systemitem> を追加し、 <literal>example_web.org</literal> のインスタンスを起動します。</para>
   </listitem>
  </itemizedlist>
 </sect1>
 <sect1 xml:id="sec.apache2.security">
  <title>セキュリティ問題の回避</title>

  <para>Web サーバは全世界のインターネットに公開される仕組みであるため、常に管理面の労力を必要とします。ソフトウエアに起因するセキュリティ問題のほか、設定ミスによる情報漏洩なども必然的に発生しうる問題となります。ここでは、これらの問題を解決するためのいくつかのヒントを示しています。</para>

  <sect2 xml:id="sec.apache2.security.up-to-date">
   <title>最新版のソフトウエアの使用</title>
   <para>Apache ソフトウエアに対して脆弱性が発見されると、 &suse; はセキュリティ勧告を発信します。この勧告には詳細の説明のほか、脆弱性の修正手順が含まれています。 &suse; のセキュリティ勧告は、下記の場所で公開されます (<!-- NOTE: These are mainly expressed in English -->いずれも基本的には英語のみでの提供となります):</para>
   <itemizedlist mark="bullet" spacing="normal">
    <listitem>
     <formalpara>
      <title>Web ページ</title>
      <para><link xlink:href="http://www.suse.com/support/security/"/></para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>メーリングリスト</title>
      <para><link xlink:href="http://lists.opensuse.org/opensuse-security-announce/"/></para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>セキュリティアナウンス</title>
      <para><link xlink:href="http://www.suse.com/support/update/"/></para>
     </formalpara>
    </listitem>
   </itemizedlist>
  </sect2>

  <sect2 xml:id="sec.apache2.security.permissions">
   <title>DocumentRoot のアクセス権</title>
   <para>&productname; では、 <systemitem>DocumentRoot</systemitem> で指定されている <filename>/srv/www/htdocs</filename> ディレクトリと、 CGI のディレクトリ <filename>/srv/www/cgi-bin</filename> については、 <systemitem>root</systemitem> のユーザおよびグループが設定されています。これらのアクセス権については、変更すべきではありません。これらのディレクトリが全てのユーザに対して書き込み可能になってしまうと、どのユーザからでもファイルを保存できることになってしまいます。ここに配置されたファイルは、 Apache 側では <systemitem>wwwrun</systemitem> というユーザの権限で実行されるため、場合によっては予期しないファイルシステムへのアクセスが為されてしまうことがあります。また、仮想ホストに対して <systemitem>DocumentRoot</systemitem> や CGI のディレクトリを設定する場合は、 <filename>/srv/www</filename> 以下のサブディレクトリを使用するものとし、それらのディレクトリに対して、 <systemitem class="username">root</systemitem> のユーザおよびグループに所属させるようにしてください。</para>
  </sect2>

  <sect2 xml:id="sec.apache2.security.filesystem">
   <title>ファイルシステムのアクセス権</title>
   <para>既定では、ファイルシステム全体へのアクセスは <filename>/etc/apache2/httpd.conf</filename> で禁止されるようになっています。これらのディレクティブについては、削除したりしてはなりません。 Apache が読み込む必要のあるディレクトリに限定して、アクセスを許可するよう設定してください。詳しくは <xref linkend="sec.apache2.configuration.manually.vhost.basic_configuration"/> をお読みください。また、指定したディレクトリ内には、パスワードやシステムの設定ファイルなど、機密を確保する必要のあるファイルを配置していないことをご確認ください。誤って配置してしまうと、外部から読み取られてしまう危険性があります。</para>
  </sect2>

  <sect2 xml:id="sec.apache2.security.cgi">
   <title>CGI スクリプト</title>
   <para>PHP や SSI などのプログラミング言語で書かれた対話的なスクリプトは、本質的には任意のコマンドを実行することができる仕組みであるため、一般的なセキュリティ問題となりうる存在であります。サーバが実行するスクリプトについては、システム管理者が信頼する情報源から得たスクリプトだけになるようにすべきです。一般ユーザに対してスクリプトを作成させて実行できるようにするのは、適切ではありません。また、全てのスクリプトに対して、監査の仕組みを用意しておくことをお勧めします。</para>
   <para>スクリプトの管理をできるだけ簡単に行ないたい場合は、 CGI スクリプトの実行をサーバ全体で許可するのではなく、特定のディレクトリに限定して許可するようにするとよいでしょう。それぞれ <systemitem>ScriptAlias</systemitem> と <systemitem>Option ExecCGI</systemitem> のディレクティブで設定することができます。 &productname; の既定の設定では、どこでも CGI スクリプトを実行できるような許可は与えていません。</para>
   <para>また、 CGI スクリプトは全て同じユーザで実行されるため、場合によってはスクリプト間で競合が発生することがあります。 suEXEC モジュールを利用することで、 CGI スクリプトを異なるユーザやグループで実行することができます。</para>
  </sect2>

  <sect2 xml:id="sec.apache2.security.users">
   <title>ユーザディレクトリ</title>
   <para><systemitem>mod_userdir</systemitem> もしくは <systemitem>mod_rewrite</systemitem> モジュールを利用してユーザディレクトリを有効化した場合、 <filename>.htaccess</filename> ファイルへのアクセスについては、禁止しておくことを強くお勧めします。これは、このファイルがセキュリティ設定を上書きできてしまう存在であるためです。少なくとも <systemitem>AllowOverRide</systemitem> を利用して、ユーザ側で設定できる項目を制限してください。 &productname; では、 <filename>.htaccess</filename> ファイルへのアクセスは既定で有効化されていますが、 <systemitem>mod_userdir</systemitem> モジュールを利用した場合、 <systemitem>Option</systemitem> ディレクティブによる設定の上書きは許可されないようになっています (詳しくは <filename>/etc/apache2/mod_userdir.conf</filename> 設定ファイルをお読みください) 。</para>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.apache2.troubleeshooting">
  <title>トラブルシューティング</title>

  <para>Apache が起動しない場合や Web ページにアクセスできない場合、もしくはユーザが Web サーバに接続できない場合は、問題の原因を突き止めることが重要です。ここでは、一般的なエラーの出力先と、主要なチェック項目について説明しています:</para>

  <variablelist>
   <varlistentry>
    <term><systemitem class="service">apache2.service</systemitem> サブコマンドの出力:</term>
    <listitem>
     <para><filename>/usr/sbin/apache2ctl</filename> バイナリで Web サーバを開始したり停止したりするのではなく、 <command>systemctl</command> コマンドをお使いください (詳しくは <xref linkend="sec.apache2.start_stop"/> をお読みください) 。なお、 <command>systemctl status apache2</command> と入力して実行すると、エラーに関する詳細な情報を出力することができます。ここから設定エラーを修正するためのヒントが得られます。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>ログファイルと饒舌性</term>
    <listitem>
     <para>致命的なエラーであってもそうでなくても、 Apache のログファイルを調査することで原因を調査することができます。既定の設定では、主なエラーログは <filename>/var/log/apache2/error_log</filename> に出力されます。これに加えて <systemitem>LogLevel</systemitem> ディレクティブを使用することで、ログファイル内により詳しい情報を出力することができます。</para>
     <tip>
      <title>シンプルなテストについて</title>
      <para>まずは <command>tail -F /var/log/apache2/<replaceable>エラーログファイル名</replaceable></command> を実行して、 Apache のログファイルを監視してください。監視を続けた状態で <command>systemctl restart apache2</command> を実行し、ブラウザで接続してみて出力される内容を確認すると良いでしょう。</para>
     </tip>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>ファイアウオールとポート</term>
    <listitem>
     <para>良くあるミスとして、 Apache が待ち受けているポートをファイアウオール側で開いていないという問題があります。 &yast; で Apache を設定した場合は、この問題に対応するためのオプションが用意されています (詳しくは <xref linkend="sec.apache2.configuration.yast"/> をお読みください) 。 Apache を手作業で設定している場合は、 &yast; のファイアウオールモジュールを利用して、 HTTP および HTTPS に対するファイアウオールのポートを開いてください。</para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>これらのヒントを利用しても原因がわからない場合は、 <link xlink:href="http://httpd.apache.org/bug_report.html"/> にある Apache のバグデータベースを利用することもできます。これに加えて、 Apache ユーザコミュニティのメーリングリストをお使いいただくこともできます。詳しくは <link xlink:href="http://httpd.apache.org/userslist.html"/> をお読みください。</para>
 </sect1>
 <sect1 xml:id="sec.apache2.more_information">
  <title>さらなる情報</title>

  <para><systemitem>apache2-doc</systemitem> パッケージには、様々な言語に対応した Apache の完全マニュアルが用意されています。このパッケージは既定ではインストールされていません。最も手短かにインストールするには、 <command>zypper in apache2-doc</command> コマンドをお使いください。インストールを行なうと、 Apache のマニュアルが <link xlink:href="http://localhost/manual/"/> からアクセスできるようになります。また、オンライン版のマニュアルにアクセスするには、 <link xlink:href="http://httpd.apache.org/docs-2.4/"/> をご利用ください。また、 SUSE 固有の設定ヒントについては、 <filename>/usr/share/doc/packages/apache2/README.*</filename> 内に用意されています。</para>

  <sect2 xml:id="sec.apache2.more_information.apache22">
   <title>Apache 2.4</title>
   <para>Apache 2.4 での新機能の一覧については、 <link xlink:href="http://httpd.apache.org/docs/2.4/new_features_2_4.html"/> をお読みください。また、 2.2 から 2.4 へのアップグレードに関する情報は、 <link xlink:href="http://httpd.apache.org/docs-2.4/upgrading.html"/> にて提供されています。</para>
  </sect2>

  <sect2 xml:id="sec.apache2.more_information.modules">
   <title>Apache モジュール</title>
   <para>Apache の外部モジュールに関する情報については、概要説明が <xref linkend="sec.apache2.modules.external"/> に用意されています。より詳しくお読みになりたい場合は、下記の場所をご覧ください:</para>
   <variablelist>
    <varlistentry>
     <term><systemitem>mod_apparmor</systemitem></term>
     <listitem>
      <para><link xlink:href="http://ja.opensuse.org/SDB:AppArmor"/></para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>mod_php5</systemitem></term>
     <listitem>
      <para><link xlink:href="http://www.php.net/manual/ja/install.unix.apache2.php"/></para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>mod_python</systemitem></term>
     <listitem>
      <para><link xlink:href="http://www.modpython.org/"/></para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>mod_security</systemitem></term>
     <listitem>
      <para><link xlink:href="http://modsecurity.org/"/></para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 xml:id="sec.apache2.more_information.cgi">
   <title>開発</title>
   <para>Apache のモジュール開発に関する情報や、 Apache Web サーバ自身の開発に参加したい場合は、下記をお読みになることをお勧めします:</para>
   <variablelist>
    <varlistentry>
     <term>Apache 開発者向け情報</term>
     <listitem>
      <para><link xlink:href="http://httpd.apache.org/dev/"/></para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Apache 開発者向けドキュメンテーション</term>
     <listitem>
      <para><link xlink:href="http://httpd.apache.org/docs/2.4/developer/"/></para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 xml:id="sec.apache2.more_information.miscellaneous_sources" os="sles;sled">
   <title>その他の情報</title>
   <para>&productname; 内の Apache に固有の問題に直面した場合は、まず <link xlink:href="http://www.suse.com/support"/> にある Technical Information Search をお使いください。また、 Apache の履歴については <link xlink:href="http://httpd.apache.org/ABOUT_APACHE.html"/> をお読みください。こちらには、サーバが Apache と呼ばれるようになった理由も説明されています。</para>
  </sect2>
 </sect1>
</chapter>
