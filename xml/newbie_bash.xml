<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter [
<!ENTITY % entities SYSTEM "entity-decl.ent">
%entities;
]>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en" xml:id="cha.new.bash">
 <title>シェルの基本</title>
 <para>Linux で様々な作業を行なう際、ほとんどの作業はコマンドラインインタプリタ (シェル) を使用せずに作業ができてしまいます。 Linux システムが起動すると、通常はログイン処理を促し、それ以降の作業を行なうグラフィカルなユーザインターフェイスが表示されます。Linux でのグラフィカルなユーザインターフェイスは、 KDE や GNOME など、インストール時に選択したデスクトップ環境を一般的に使用します。</para>
 <para>しかしながら、グラフィカルなインターフェイスが利用できなくなる問題に引っかかってしまったような場合などに備えて、シェルの使い方の基本を覚えておくと便利です。たとえば X Window System の問題が発生したような場合、シェルの知識を持っておかないと、コマンドの入力 1 つにしても恐る恐る実行することになってしまいます。また、問題が発生していなくても、場合によっては、コマンドラインでやってしまったほうがずっと手っ取り早い作業もあります。</para>
 <para>Unix や Linux の場合、動作やコマンド体系が少しずつ異なる複数のシェルが用意されています。 &productnamereg; での既定のシェルは、 Bash (GNU Bourne-Again Shell) と呼ばれているシェルです。</para>
 <para>下記の章では、 bash シェルのごく基本的な使い方と、コマンドラインを利用した基本的な作業のやり方について説明しています。シェルについてさらに詳しく学びたい場合や、既に <quote>パワーユーザ</quote> であるとご自身でお考えの方は、 <xref linkend="cha.adm.shell"/> をお読みください。</para>
 <sect1 xml:id="sec.new.bash.start">
  <title>シェルの起動</title>

  <para>基本的には、お使いのコンピュータを起動してグラフィカルユーザインターフェイスが表示されている状況からは、下記のいずれかの方法でシェルを起動することができます:</para>

  <itemizedlist>
   <listitem>
    <para>グラフィカルなユーザインターフェイスとは別の画面でシェルを起動する</para>
   </listitem>
   <listitem>
    <para>グラフィカルなユーザインターフェイス <emphasis>内</emphasis> でシェルを起動する</para>
   </listitem>
  </itemizedlist>

  <para>前者の方式はいつでも利用できる仕組みではありますが、既に KDE や GNOME などのデスクトップ環境にログインしている場合は、後者のほうが都合がよいでしょう。いずれの方法を選択した場合も、シェルとグラフィカルユーザインターフェイスとの間を切り替えることができます。</para>

  <para>前者の方法でシェルを起動するには、グラフィカルユーザインターフェイスを終了するため、 <keycombo> <keycap function="control"/> <keycap function="alt"/> <keycap>F2</keycap> </keycombo> を押します。するとグラフィカルな表示が消え、テキストベースのログインプロンプトが表示されるようになります。ここからユーザ名を入力して <keycap function="enter"/> を押すと、パスワードの入力を求められますので、パスワードを入力して再度 <keycap function="enter"/> を押します。すると、下記のようなプロンプトが表示されます:</para>

<screen> <co xml:id="co.prompt.user"/>&nbsp;&nbsp;&nbsp;<co xml:id="co.prompt.hostname"/>&nbsp;&nbsp;&nbsp;<co xml:id="co.prompt.path"/>
tux@linux:~&gt;</screen>

  <calloutlist>
   <callout arearefs="co.prompt.user">
    <para>ログインしたユーザ名を表わします。</para>
   </callout>
   <callout arearefs="co.prompt.hostname">
    <para>コンピュータのホスト名を表わします。</para>
   </callout>
   <callout arearefs="co.prompt.path">
    <para>現在の (カレント) ディレクトリのパスを表わします。ログインしてすぐの状態では、カレントディレクトリはホームディレクトリになっています。ホームディレクトリは<literal>~</literal> (チルダ) で表わされます。</para>
   </callout>
  </calloutlist>

  <para>ネットワーク上離れた場所からログインしている場合でも、上記で出力されるホスト名はログイン先のものになりますので、どこで作業を行なっているのかが明らかになるようになっています。</para>

  <para>カーソルがこのプロンプトの後ろに表示されていれば、お使いのコンピュータシステムでコマンドを入力できる状態にあることになります。たとえば <command>ls</command> <option>-l</option> のように入力すると、詳細な出力形式でカレントディレクトリの内容を表示することができます。なお、シェルの使用を終了し、元の画面に戻りたい場合は、 <command>exit</command> と入力して <keycap function="enter"/> を押してください。その後、 <keycombo> <keycap function="alt"/> <keycap>F7</keycap> </keycombo> を押すと、元のグラフィカルなユーザインターフェイスに戻ることができます。デスクトップも動作中のアプリケーションも、元のままになっているはずです。</para>

  <para>GNOME や KDE のデスクトップ環境にログイン済みで、デスクトップ内に端末 (シェル) ウインドウを表示させたい場合は、 <keycombo> <keycap function="alt"/> <keycap>F2</keycap> </keycombo> を押して <command>konsole</command> (KDE の場合) もしくは <command>gnome-terminal</command> (GNOME の場合) を入力します。すると、デスクトップ内に端末ウインドウが表示されるようになります。既にデスクトップにログインしているため、上述のものと同じシステム周りの情報が表示されます。ここからコマンドを入力して実行すると、デスクトップと同時並行で処理が動作するようになります。デスクトップ内の他のアプリケーションに切り替えたい場合は、単にそれぞれのアプリケーションのウインドウをマウスで選択するか、パネル内のタスクバーなどで選択を行なってください。端末ウインドウを閉じるには、 <keycombo> <keycap function="alt"/> <keycap>F4</keycap> </keycombo> を押します。</para>
 </sect1>
 <sect1 xml:id="sec.new.bash.commands">
  <title>コマンドの入力</title>

  <para>シェル内にプロンプトが表示されれば、コマンドを受け取って実行することができることになります。コマンドには複数の要素が存在しています。最初はコマンドそれ自身で、その後ろにパラメータやオプションが続きます。また、コマンドやオプションは、<keycap function="left"/> , <keycap function="right"/> , <keycap function="home"/> , <keycap function="end"/> , <keycap function="backspace"/> (バックスペース), <keycap function="delete"/> , <keycap function="space"/> (スペース) の各キーで編集を行なうことができます。入力を間違ってしまったりした場合は、これらのキーで編集作業を行なうことができます。コマンドは <keycap function="enter"/> が押されるまで、実行はされません。</para>

  <important>
   <title>便りが無いのは良い便り</title>
   <para>シェルは寡黙です。グラフィカルなユーザインターフェイスとは異なり、コマンドが実行した際にも確認メッセージは表示しないのが通常です。何らかの問題やエラーが発生した場合や、コマンドの実行時に特定のオプションを指定して出力するようにした場合にのみ、メッセージが表示されます。</para>
   <para>なお、削除をするにあたっては、特に注意する必要があります。たとえば <command>rm</command> というコマンドはファイルを削除するためのコマンドですが、特に何もオプションを指定しない限り確認メッセージの類は表示されず、そのまま黙って削除を実行してしまいます。</para>
  </important>

  <sect2 xml:id="sec.new.bash.commands.simple">
   <title>オプション無しでのコマンドの使用</title>
   <para><xref linkend="sec.new.bash.accperm.ugo"/> では、最も基本的なコマンドである <command>ls</command> を使用しました。このコマンドはディレクトリの内容を表示するためのコマンドで、オプションを指定しても、指定しなくても実行することができます。 <command>ls</command> コマンドをオプション無しで実行すると、現在のディレクトリに対する内容を簡潔に出力します:</para>
<screen>&prompt.user;ls
bin Desktop Documents public_html tux.txt
&prompt.user;</screen>
   <para>Linux では、ファイルの拡張子は任意で、必須ではありません。上記の例では <literal>.txt</literal> という拡張子が付けられたファイルがありますが、拡張子を指定しなくてもかまいません。このような仕組みであることから、 <command>ls</command> の出力ではファイルとフォルダの区別が難しくなっていますが、既定の bash シェルでは色を付けて出力するようになっています (ディレクトリは青色、ファイルは黒色) ので、ここからファイルとフォルダを区別することができます。</para>
  </sect2>

  <sect2 xml:id="sec.new.bash.commands.options">
   <title>オプション付きでのコマンドの使用</title>
   <para>ディレクトリの内容をより詳しく表示するには、 <command>ls</command> に文字列でオプションを指定するのが適切です。オプションはコマンドの動作を修正するための仕組みで、要件にあわせた動作を行なうためのものです。コマンドとオプションの間はスペースで区切り、オプションの場合は通常ハイフンで始まります。たとえば <command>ls</command> <option>-l</option> (<quote>long</quote> (長い) の意味) を実行すると、同じディレクトリをずっと詳しく表示します:</para>
<screen>&prompt.user;ls -l
drwxr-xr-x 1 tux users     48 2015-06-23 16:08 bin
drwx---r-- 1 tux users  53279 2015-06-21 13:16 Desktop
drwx------ 1 tux users    280 2015-06-23 16:08 Documents
drwxr-xr-x 1 tux users  70733 2015-06-21 09:35 public_html
-rw-r--r-- 1 tux users  47896 2015-06-21 09:46 tux.txt
&prompt.user;</screen>
   <para>この出力には、各オブジェクトに対する情報が書かれています:</para>
<screen>drwxr-xr-x<co xml:id="co.ls_l.perm"/> 1<co xml:id="co.ls_l.a"/> tux<co xml:id="co.ls_l.user"/> users<co xml:id="co.ls_l.group"/> 48<co xml:id="co.ls_l.size"/> 2006-06-23 16:08<co xml:id="co.ls_l.date"/> bin<co xml:id="co.ls_l.name"/></screen>
   <calloutlist>
    <callout arearefs="co.ls_l.perm">
     <para>オブジェクトの種類とアクセス権を示しています。詳しくは <xref linkend="sec.new.bash.accperm.ugo"/> をお読みください。</para>
    </callout>
    <callout arearefs="co.ls_l.a">
     <para>このファイルに対するハードリンク数を示しています。</para>
    </callout>
    <callout arearefs="co.ls_l.user">
     <para>ファイルやディレクトリの所有者を示しています。詳しくは <xref linkend="sec.new.bash.accperm.ugo"/> をお読みください。</para>
    </callout>
    <callout arearefs="co.ls_l.group">
     <para>ファイルやディレクトリに割り当てられたグループを示しています。詳しくは <xref linkend="sec.new.bash.accperm.ugo"/> をお読みください。</para>
    </callout>
    <callout arearefs="co.ls_l.size">
     <para>バイト単位でのファイルサイズを示しています。</para>
    </callout>
    <callout arearefs="co.ls_l.date">
     <para>最終変更日時を示しています。</para>
    </callout>
    <callout arearefs="co.ls_l.name">
     <para>オブジェクトの名前を示しています。</para>
    </callout>
   </calloutlist>
   <para>通常は、最初のオプションに対してだけハイフンを付け、それ以降のオプションはスペースを入れずに入力することで、複数のオプションをまとめて記述することができます。たとえばディレクトリ内の全てのファイルを長い形式で出力させたい場合は、 <option>-l</option> と <option>-a</option> (<quote>all</quote> (全て) の意味) を組み合わせて <command>ls</command> コマンドに指定し、 <command>ls</command> <option>-la</option> のようにして実行します。これでディレクトリ内の隠しファイル (ドットで始まるファイル、たとえば <literal>.hiddenfile</literal> など) をあわせて表示するようになります。</para>
   <para><command>ls</command> で出力される内容は、ファイル名のアルファベット順に並び替えられます。ですが、グラフィカルなファイルマネージャと同様に、 <command>ls</command> <option>-l</option> で出力される内容を、日付や拡張子、ファイルサイズなどで並び替えることができます:</para>
   <itemizedlist>
    <listitem>
     <para>日時で並べ替えるには、 <command>ls</command> <option>-lt</option> のように指定して実行します (新しいものを先に表示します) 。</para>
    </listitem>
    <listitem>
     <para>拡張子で並べ替えるには、 <command>ls</command> <option>-lx</option> のように指定して実行します (拡張子の無いものが先に表示されます) 。</para>
    </listitem>
    <listitem>
     <para>ファイルサイズで並べ替えるには、 <command>ls</command> <option>-lS</option> のように指定して実行します (大きいものが先に表示されます) 。</para>
    </listitem>
   </itemizedlist>
   <para>逆順で並び替えるには、お使いの <command>ls</command> コマンドに <option>-r</option> オプションを追加します。たとえば <command>ls</command> <option>-lr</option> のように実行すると、ディレクトリの内容一覧をアルファベットの逆順で出力します。また、 <command>ls</command> <option>-ltr</option> を実行すると古いファイルを先に表示することができます。このほかにも、 <command>ls</command> には多数の便利なオプションが用意されています。以下の章では、それらの調べ方を示しています。</para>
  </sect2>

  <sect2 xml:id="sec.new.bash.commands.shortcuts">
   <title>bash ショートカットキー</title>
   <para>コマンドを入力して実行していると、シェルの画面がコマンドとその出力で埋め尽くされることになります。下記の表では、シェル内のナビゲーションと編集に役立つキーを示しています。</para>
   <informaltable>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>
        <para>ショートカットキー</para>
       </entry>
       <entry>
        <para>機能</para>
       </entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
        <para><keycombo> <keycap function="control"/> <keycap>L</keycap> </keycombo></para>
       </entry>
       <entry>
        <para>画面を消去し、現在の行をページの冒頭に移動します。</para>
       </entry>
      </row>
      <row>
       <entry>
        <para><keycombo> <keycap function="control"/> <keycap>C</keycap> </keycombo></para>
       </entry>
       <entry>
        <para>現在実行中のコマンドを中止します。</para>
       </entry>
      </row>
      <row>
       <entry>
        <para><keycombo> <keycap function="shift"/> <keycap function="pageup"/> </keycombo></para>
       </entry>
       <entry>
        <para>上にスクロールします。</para>
       </entry>
      </row>
      <row>
       <entry>
        <para><keycombo> <keycap function="shift"/> <keycap function="pagedown"/> </keycombo></para>
       </entry>
       <entry>
        <para>下にスクロールします。</para>
       </entry>
      </row>
      <row>
       <entry>
        <para><keycombo> <keycap function="control"/> <keycap>U</keycap> </keycombo></para>
       </entry>
       <entry>
        <para>カーソルのある位置から行頭までを削除します。</para>
       </entry>
      </row>
      <row>
       <entry>
        <para><keycombo> <keycap function="control"/> <keycap>K</keycap> </keycombo></para>
       </entry>
       <entry>
        <para>カーソルのある位置から行末までを削除します。</para>
       </entry>
      </row>
      <row>
       <entry>
        <para><keycombo> <keycap function="control"/> <keycap>D</keycap> </keycombo></para>
       </entry>
       <entry>
        <para>シェルのセッションを閉じます。</para>
       </entry>
      </row>
      <row>
       <entry>
        <para><keycap function="up"/> , <keycap function="down"/></para>
       </entry>
       <entry>
        <para>過去に実行したコマンドの履歴を参照します。</para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </informaltable>
  </sect2>
 </sect1>

 <sect1 xml:id="sec.new.bash.commands.help">
  <title>ヘルプについて</title>
  <para>コマンドの名前は覚えていたものの、オプションやコマンドの書式を忘れてしまった場合は、下記のいずれかの方法で調べることができます:</para>
  <variablelist>
   <varlistentry>
    <term><option>--help</option> / <option>-h</option> オプション</term>
    <listitem>
     <para>特定のコマンドに対してオプションを確認したいだけであれば、コマンドの後ろにスペースで区切って <option>--help</option> と指定してください。 <option>--help</option> オプションは多数のコマンドに実装されています。たとえば <command>ls</command> <option>--help</option> のように入力すると、 <command>ls</command> コマンドに対する全てのオプションが表示されます。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>マニュアルページ</term>
    <listitem>
     <para>様々なコマンドに対して詳しく学びたい場合は、マニュアルページを読むこともできます。マニュアルページには、コマンドの動作に関する簡単な説明も付属しています。マニュアルページは <command>man</command> コマンドでアクセスすることができます。マニュアルページを読みたいコマンドを、スペースで区切って指定してください。たとえば <command>man&nbsp;ls</command> のように実行します。</para>
     <para>マニュアルページはシェル内に直接表示されます。マニュアルページ内を移動するには、下記のキーをお使いください:</para>
     <itemizedlist>
      <listitem>
       <para>単純な上下移動: <keycap function="pageup"/> , <keycap function="pagedown"/></para>
      </listitem>
      <listitem>
       <para>マニュアルページの冒頭および末尾への移動: <keycap function="home"/> , <keycap function="end"/></para>
      </listitem>
      <listitem>
       <para>マニュアルページの終了: <keycap>Q</keycap></para>
      </listitem>
     </itemizedlist>
     <para><command>man</command> コマンドそのものについても、マニュアルページで調べることができます。詳しくは <command>man man</command> と入力してください。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>info ページ</term>
    <listitem>
     <para>info ページは、特定のコマンドに対してより詳しい説明を記述しているものです。特定のコマンドに対する info ページを読むには、 <command>info</command> に続いてコマンド名を指定してください (例: <command>info ls</command>) 。</para>
     <para>info ページはシェル内に直接表示されます。 info ページ内を移動するには、下記のキーをお使いください:</para>
     <itemizedlist>
      <listitem>
       <para>セクション (<emphasis>ノード</emphasis>) 内の前もしくは後ろへの移動: <keycap function="space"/> , <keycap function="backspace"/> </para>
      </listitem>
      <listitem>
       <para>単純な上下移動: <keycap function="pageup"/> , <keycap function="pagedown"/></para>
      </listitem>
      <listitem>
       <para>info ページの終了: <keycap>Q</keycap></para>
      </listitem>
     </itemizedlist>
    </listitem>
   </varlistentry>
  </variablelist>
  <para>なお、全てのコマンドに対してマニュアルページや info ページが用意されているとは限らないことに注意してください。両方が用意されているもの (主なコマンド類) のほか、マニュアルページと info ページのいずれかが用意されているものや、どちらも用意されていないものもあります。</para>
 </sect1>

 <sect1 xml:id="sec.new.bash.fildir">
  <title>ファイルやディレクトリの作業</title>

  <para>ある特定のファイルやディレクトリを指定する際、そのファイルやディレクトリへの経路 (パス) を指定する必要があります。パスの指定方法には、下記の 2 種類があります:</para>

  <variablelist>
   <varlistentry>
    <term>絶対パス</term>
    <listitem>
     <para>ルートディレクトリ ( <filename>/</filename> ) から、そのファイルやディレクトリに至る経路 (パス) 全体を表わす方法です。たとえば、ホームディレクトリ内の <filename>Documents</filename> というディレクトリにある <filename>file.txt</filename> というファイルの絶対パスは、下記のようになります:</para>
     <screen>/home/&exampleuser_plain;/Documents/file.txt</screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>相対パス</term>
    <listitem>
     <para>現在の作業ディレクトリ (カレントディレクトリ) から、そのファイルやディレクトリに至る経路 (パス) を表わす方法です。カレントディレクトリが <filename>/home/&exampleuser_plain;</filename> であった場合、ホームディレクトリ内の <filename>Documents</filename> 内にある <filename>file.txt</filename> ファイルの相対パスは、下記のようになります:</para>
     <screen>Documents/file.txt</screen>
     <para>たとえばカレントディレクトリが <filename>/home/&exampleuser_plain;/Music</filename> であった場合は、ホームディレクトリにいったん戻るための経路を記述しなければ、上と同じファイルを指定することができません。この場合は、<filename>..</filename> を指定して、一階層上のディレクトリに移動してから、残りのディレクトリやファイルの経路を指定します:</para>
     <screen>../Documents/file.txt</screen>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>パスの表記では複数のディレクトリ名とファイル名を組み合わせますが、それぞれはスラッシュで区切ります。また、絶対パスは必ずスラッシュで始まりますが、相対パスはスラッシュ以外の文字で始まります。また、相対パスの場合、 1 つまたは 2 つのドットを使用することがあります。</para>

  <para>コマンドを入力する場合、パスはどちらの方法で指定してもかまいません。いずれか入力が楽なほうをお選びください。どちらを入力しても結果は同じです。また、カレントディレクトリを変更するには、 <command>cd</command> コマンドを使用してパスを指定します。</para>

  <note>
   <title>ファイル名やディレクトリ名における空白 (スペース) の処理について</title>
   <para>ファイル名やディレクトリ名に空白を含む場合、空白の前にバックスラッシュ<!-- Japanese original contents start --><!-- It says 'backslash may be rendered as Yen mark (Japanese currency sign) depending on the font' --> (フォントによっては円マークとして描画される場合があります) <!-- Japanese original contents end --> ( <literal>\</literal> ) を付けてスペースを避ける (エスケープ) 処理をするか、もしくはパス全体を引用符で括って指定します。このように指定しないと、 bash は<filename>My Documents</filename> のようなファイル名を 2 つのファイル名もしくはディレクトリ名であるものと解釈してしまい、この例では <filename>My</filename> と <filename>Documents</filename> の 2 つのパスになってしまいます。<!--The difference between single and double quotes is that variable expansion takes place within double quotes. Single quotes ensure that the shell sees the quoted string literally.--></para>
  </note>

  <para>なお、パスを指定する際は、下記の <quote>ショートカット</quote> を利用して、入力を省略することができます:</para>

  <itemizedlist>
   <listitem>
    <para>チルダ記号 ( <literal>~</literal> ) はホームディレクトリのショートカットです。たとえば、お使いのホームディレクトリの内容を一覧表示したい場合は、 <command>ls</command> <option>~</option> のように指定することができます。また、他のユーザのホームディレクトリを指定する場合は、 <command>ls</command> <option>~<replaceable>ユーザ名</replaceable> </option> のように入力します (このコマンドは、そのユーザのホームディレクトリを見る権限が与えられている場合にのみ出力することができます。詳しくは <xref linkend="sec.new.bash.accperm"/> をお読みください) 。たとえば <command>ls ~&exampleuser_plain;</command> のようなコマンドを実行すると、 &exampleuser; というユーザ名のホームディレクトリの内容を一覧表示することになります。この仕組みは、たとえばネットワーク環境などで <filename>/home</filename> 以外のディレクトリ内にホームディレクトリが存在するような場合に、便利なショートカットとなります。</para>
    <para>なお、カレントディレクトリがどこであっても、ホームディレクトリに戻りたい場合は <command>cd ~</command> と入力するか、もしくは単にオプション無しで <command>cd</command> と入力して実行してください。</para>
   </listitem>
   <listitem>
    <para>相対パスで指定している場合は、カレントディレクトリはドット 1 つ ( <literal>.</literal> ) で指定することができます。これは特に <command>cp</command> (ファイルやディレクトリのコピー) や <command>mv</command> (ファイルやディレクトリの移動) 等のコマンドを実行する際に便利です。</para>
   </listitem>
   <listitem>
    <para>また、ドットを 2 つ並べる ( <literal>..</literal> ) と、ツリー構造内で 1 段上位のディレクトリ (ルートディレクトリに 1 段だけ近いほうのディレクトリ。親ディレクトリとも呼びます) を表わすことができます。たとえばカレントディレクトリの親ディレクトリに移動するには <command>cd ..</command> と入力して実行しますし、 2 段上位のディレクトリに移動したい場合は、 <command>cd ../..</command> 等のように指定して実行します。</para>
   </listitem>
  </itemizedlist>

  <para>知識をより深めるため、下記には様々な例を示します。 bash を利用すれば、ファイルやディレクトリに対する様々な基本作業を行なうことができます。</para>

  <sect2 xml:id="sec.new.bash.fildir.ex">
   <title>ファイルやディレクトリの作業例</title>
   <para>ここでは、ホームディレクトリ内のどこかにあるファイルを、 <filename>/tmp</filename> のサブディレクトリにコピーする流れを示しています。もちろん、コピー先のディレクトリも流れの中で作成するものとします。</para>
   <procedure>
    <title>ディレクトリの作成と移動</title>
    <para>カレントディレクトリがホームディレクトリであるものとして、まずは <filename>/tmp</filename> 内にサブ (1 段下位の／子の) ディレクトリを作成します:</para>
    <step>
     <para>下記のように実行します:</para>
<screen>&prompt.user;mkdir /tmp/test</screen>
     <para><command>mkdir</command> は <quote>make directory</quote> (ディレクトリの作成) の意味です。このコマンドを実行すると、新しい <filename>test</filename> という名前のディレクトリを <filename>/tmp</filename> ディレクトリ内に作成します。この場合、 <filename>test</filename> ディレクトリを作成する際に使用したパスは絶対パスです。</para>
    </step>
    <step>
     <para>作成されたディレクトリを確認するには、下記のように実行します:</para>
<screen>&prompt.user;ls -l /tmp</screen>
     <para>新しく作成した <filename>test</filename> ディレクトリが、<filename>/tmp</filename> ディレクトリ内に作成されているはずです。</para>
    </step>
    <step>
     <para>新しく作成したディレクトリに移動するには、下記のように実行します:</para>
<screen>&prompt.user;cd /tmp/test</screen>
    </step>
   </procedure>
   <procedure>
    <title>ファイルの作成とコピー</title>
    <para>次に、ホームディレクトリ内のサブディレクトリに新しいファイルを作成し、これを <filename>/tmp/test</filename> 内にコピーします。このとき、相対パスを利用して指定を行ないます。</para>
    <important>
     <title>既存のファイルへの上書き</title>
     <para>ファイルのコピーや移動、名前変更を行なう前に、宛先となるディレクトリ内に同じ名前のファイルが存在していないかどうかをご確認ください。存在している場合は、別のファイル名でコピーや移動、名前変更を行なうか、もしくは <command>cp</command> や <command>mv</command> などのコマンドに <option>-i</option> のようなオプションを追加してください。これにより、既存のファイルに上書きする際に、確認プロンプトが表示されるようになります。オプションを設定しないと、 bash は何も確認を行なうことなくファイルを上書きしてしまいます。</para>
    </important>
    <step>
     <para>まずはホームディレクトリの内容を一覧表示します。下記のように入力して実行します:</para>
<screen>&prompt.user;ls -l ~</screen>
     <para><!-- NOTE: When in environment other than English, "Documents" will be translated to something. But it may be difficult to input within terminal. So we changed the explanation in this translation. -->まずは新しいディレクトリ <filename>Documents</filename> を、ホームディレクトリ内に作成します:</para>
<screen>&prompt.user;mkdir ~/Documents</screen>
    </step>
    <step>
     <para>続いて、作成した <filename>Documents</filename> ディレクトリ内に <filename>myfile.txt</filename> という空のファイルを作成します:</para>
<screen>&prompt.user;touch ~/Documents/myfile.txt</screen>
     <para>通常、 <command>touch</command> コマンドは、既存のファイルに対して最終更新日時とアクセス日時を更新させるためのコマンドです。ですが、存在しないファイルに対して <command>touch</command> コマンドを実行すると、新しくファイルを作成する処理を行ないます。</para>
    </step>
    <step>
     <para>下記のように実行します:</para>
<screen>&prompt.user;ls -l ~/Documents</screen>
     <para>新しく作成したファイルが、一覧内に現われるようになります。</para>
    </step>
    <step>
     <para>新しく作成したファイルをコピーするには、下記のように実行します:</para>
<screen>&prompt.user;cp ~/Documents/myfile.txt .</screen>
     <para>なお、末尾のドットを忘れずに入力してください。</para>
     <para>このコマンドは bash に対して、ホームディレクトリ内の <filename>Documents</filename> サブディレクトリにある <filename>myfile.txt</filename> を、カレントディレクトリに名前を変更せずにコピーするよう指示しているものです。</para>
    </step>
    <step>
     <para>下記のように入力すると、結果を確認することができます:</para>
<screen>&prompt.user;ls -l</screen>
     <para><filename>/tmp/test</filename> の一覧の中に、 <filename>myfile.txt</filename> が現われるようになっているはずです。</para>
    </step>
   </procedure>
   <procedure>
    <title>ファイルやディレクトリの名前変更と削除</title>
    <para>ここでは、 <filename>myfile.txt</filename> を <filename>tuxfile.txt</filename> という名前に変更する作業を行ないます。最後はそのファイルと、 <filename>test</filename> サブディレクトリを削除します。</para>
    <step>
     <para>ファイルの名前を変更するには、下記のように実行します:</para>
<screen>&prompt.user;mv myfile.txt tuxfile.txt</screen>
    </step>
    <step>
     <para>結果を確認するには、下記のように実行します:</para>
<screen>&prompt.user;ls -l</screen>
     <para>内容の一覧には、 <filename>myfile.txt</filename> ではなく <filename>tuxfile.txt</filename> が現われているはずです。</para>
     <para><command>mv</command> は <literal>move</literal> (移動) の意味で、 2 つのパラメータを指定します: 1 つめは移動元の指定で、 2 つめは移動先の指定です。また、 <command>mv</command> には 2 種類の動作があります:</para>
     <itemizedlist>
      <listitem>
       <para>ファイルやディレクトリの名前変更</para>
      </listitem>
      <listitem>
       <para>ファイルやディレクトリの新しい場所への移動</para>
      </listitem>
      <listitem>
       <para>上記 2 つの一括実行</para>
      </listitem>
     </itemizedlist>
    </step>
    <step>
     <para>最後に、ファイルが不要であるという結論に至ったら、下記のように実行することで削除を行なうことができます:</para>
<screen>&prompt.user;rm tuxfile.txt</screen>
     <para>bash は削除の際、何も確認メッセージを表示しません。</para>
    </step>
    <step>
     <para><command>cd ..</command> のように実行すると、 1 階層上のディレクトリに移動することができます。移動の結果は、下記を実行すると確認することができます:</para>
<screen>&prompt.user;ls -l test</screen>
     <para>上記を実行して、 <filename>test</filename> ディレクトリ内に何も残っていないことを確認します。</para>
    </step>
    <step>
     <para>何も残っていなければ、下記を実行することで <filename>test</filename> ディレクトリを削除することができます:</para>
<screen>&prompt.user;rmdir test</screen>
    </step>
   </procedure>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.new.bash.root">
  <title>root での作業</title>

  <para>&rootuser; はスーパーユーザとも呼ばれ、システムの全てに対してアクセスし、様々な管理作業を実行する権限を持っています。システムに対する変更は無制限に行なうことができるほか、全てのファイルに対するアクセス権も持っています。そのため、様々な管理作業のほか、 &yast; のような管理を行なうアプリケーションを実行する場合には、 &rootuser; の権限が必要となります。</para>

  <sect2 xml:id="sec.new.bash.root.su">
   <title><command>su</command> の使用</title>
   <para>シェル内で一時的に &rootuser; になるには、下記の手順で行ないます:</para>
   <procedure>
    <step>
     <para><command>su</command> コマンドを実行します。これで &rootuser; のパスワードを尋ねられます。</para>
    </step>
    <step>
     <para>パスワードを入力します。 &rootuser; のパスワードが誤っていると、シェルはその旨を表わすメッセージを出力します。この場合は、パスワードの再入力は求められず、 <command>su</command> コマンドの入力からやり直す必要があります。パスワードの入力が正しい場合、プロンプトが変化してハッシュ記号 <literal>#</literal> が表示されるようになります。これにより、 &rootuser; であることがわかるようになっています。</para>
    </step>
    <step>
     <para>あとは必要な作業を行ないます。たとえばファイルの所有権を変更するような作業は、 &rootuser; しか行なうことができません。たとえば下記のように実行します:</para>
<screen>&prompt.user;chown &exampleuserII; kde_quick.xml</screen>
    </step>
    <step>
     <para>&rootuser; での作業が終わったら、通常の一般ユーザに戻ります。戻るには、下記のように実行します:</para>
<screen>&prompt.user;exit</screen>
     <para>プロンプトからハッシュ記号が消え、 <quote>一般の</quote> ユーザに戻ったことがわかります。</para>
     <remark condition="clarity"> 2007-07-17 - jjaeger: what about su-?
      taroth:
      left that out on purpose as this only makes sense if the user knows
      about environment variables that I didn't want to mention in this newbie
      chapter here... </remark>
    </step>
   </procedure>
  </sect2>

  <sect2 xml:id="sec.new.bash.root.sudo">
   <title><command>sudo</command> の使用</title>
   <para><command>su</command> 以外の方法としては、 <command>sudo</command> というコマンドもあります。これは superuser do (<quote>スーパーユーザで何かを行なう</quote> の意味) の略で、 &rootuser; のみが実施できる作業を、 <command>su</command> と同様に行なうことができるコマンドです。 sudo の場合は、 su と異なり、管理者側であらかじめ設定した特定のユーザに対して、特定のコマンドのみを実行できるように設定することができます。また、システム側の設定に依存しますが、 sudo では一般のユーザが &rootuser; になるにあたって、自分自身の (&rootuser; のものではない) パスワード入力で &rootuser; のコマンドを実行するように設定することもできます。さらに sudo では、パスワードの入力時に <quote>チケット</quote> を発行する仕組みになっていて、一定の時間 (通常は数分程度) が経過するまでは再度パスワード入力を求めないようにもなっています。なお &opensuse; では、既定で &rootuser; のパスワードの入力を求めるようになっています (システム管理者が設定を変更した場合を除きます) 。</para>
   <para>一般ユーザにとっては、アカウントを切り替える (&rootuser; になって作業を行ない、終わったら一般ユーザに戻る) 手間を省くことができる点がメリットとなります。たとえばファイルの所有権を sudo で変更する場合、コマンドは 3 つではなく 1 つだけで済みます:</para>
<screen>&prompt.sudo;chown &exampleuserII; kde_quick.xml</screen>
   <para>尋ねられたとおりパスワードの入力を行なうと、コマンドが実行されます。なお、実行直後に &rootuser; での作業を行なっても、パスワードの再入力は求められません。これはチケットが発行されていることによるもので、有効期限が切れるまでの間はパスワードの再入力無しでコマンドを実行することができるためです。ただし、一定の時間が経過すると、パスワードの再入力が必要となります。このような仕組みにより、一般ユーザが &rootuser; になって作業を行なっていて、一般ユーザに戻るのを忘れてマシンを放置してしまったような場合、悪意のあるユーザが横からその権限を奪取してしまうような問題を防ぐことができます。</para>
  </sect2>
 </sect1>

 <xi:include href="newbie_perm_i.xml"/>

 <sect1 xml:id="sec.new.bash.feat">
  <title>bash の省力化機能</title>

  <para>bash でコマンド入力を行なうにあたっては、数多くのキーボード入力が必要となります。この章では、入力の手間と時間を省くためのさまざまな機能を紹介しています。</para>

  <variablelist>
   <varlistentry>
    <term>履歴</term>
    <listitem>
     <para>既定では、 bash は入力したコマンドを <quote>記憶</quote> します。この機能は <emphasis>履歴</emphasis> 機能と呼ばれます。履歴には参照する機能だけでなく、再実行する機能も備わっています。履歴から実行を行なうには、 <keycap function="up"/> を何回も押して再実行したい履歴を探します。なお、 <keycap function="down"/> を押すと、新しいほうに向かって履歴を探ることができます。コマンドの冒頭部分を覚えている場合は、冒頭部分を入力して <keycap function="pageup"/> を押すと、該当する履歴を検索することができます。</para>
     <para>必要な履歴が見つかったら、 <keycap function="enter"/> を押して実行するまでの間であれば、そこからコマンドラインの編集を行なうことができます (たとえばファイル名やパスなどを変えたりすることができます) 。編集はカーソルキーを利用して行ない、入力は通常通りの入力で行ないます。</para>
     <para>また、履歴内の特定のコマンドを検索することもできます。この場合は、 <keycombo> <keycap function="control"/> <keycap>R</keycap> </keycombo> を押して、インクリメンタル検索機能をお使いください。機能が起動すると、下記のようなプロンプトになります:</para>
<screen>&prompt.user;(reverse-i-search)`':</screen>
     <para>あとは検索したい文字列を入力するだけです。文字を入力するごとに検索範囲が狭められます。入力した内容はコロン (<literal>:</literal>) の左側に、検索結果はコロンの右側にそれぞれ表示されます。検索結果を受け入れるには、 <keycap function="escape"/> を押します。これでプロンプトが元の表示に戻りますので、あとは必要に応じてコマンドラインを編集し、 <keycap function="enter"/> を押すと実行することができます。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>補完</term>
    <listitem>
     <para>bash ではもう 1 つ便利な機能があります。それはファイル名やディレクトリ名を補完する機能です。ファイル名やディレクトリ名の一部を入力して <keycap function="tab"/> を押すと、該当するものが 1 つしかなかった場合は、そのままファイル名やディレクトリ名の残りが自動的に入力され、カーソルがファイル名やディレクトリ名の末尾に移動します。このような仕組みにより、残りのオプションもすぐに入力できるようになっています。逆に、該当するものが複数存在する場合 (たとえば同じ文字で始まるファイルが複数あるような場合) は、名前が異なる箇所まで自動的に入力が行なわれます。ここからさらに <keycap function="tab"/> を押すと、該当するもの全てを一覧表示することができます。あとはどれを選択するのかをキー入力で選んで、さらに <keycap function="tab"/> を押して範囲を狭めていってください。このような仕組みは、ファイルやディレクトリが実際に存在しているかどうか (および、正しいスペルで入力しているかどうか) を確認する手段としても、利用することができます。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>ワイルドカード</term>
    <listitem>
     <para>パスを指定する箇所では、 1 つもしくは複数の文字をワイルドカードにすることができます。ワイルドカードとは、他の文字に置き換えることのできる文字で、 bash では下記の 3 種類のワイルドカード機能を提供しています:</para>
     <informaltable>
      <tgroup cols="2">
       <tbody>
        <row>
         <entry>
          <para>ワイルドカード</para>
         </entry>
         <entry>
          <para>機能</para>
         </entry>
        </row>
        <row>
         <entry>
          <para><literal>?</literal></para>
         </entry>
         <entry>
          <para>任意の 1 文字と置き換えることのできる文字です</para>
         </entry>
        </row>
        <row>
         <entry>
          <para><literal>*</literal></para>
         </entry>
         <entry>
          <para>任意の長さの文字列と置き換えることのできる文字です</para>
         </entry>
        </row>
        <row>
         <entry>
          <para><literal>[<replaceable>セット</replaceable>]</literal></para>
         </entry>
         <entry>
          <para>[] の内側で指定したグループのいずれかの文字に置き換えることのできる指定です</para>
         </entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
    </listitem>
   </varlistentry>
  </variablelist>

  <sect2 xml:id="sec.new.bash.feat.ex">
   <title>履歴／補完／ワイルドカードの使用例</title>
   <para>下記の例では、 bash におけるこれらの使用方法を説明しています。</para>
   <procedure>
    <title>履歴と補完の使用</title>
    <para>既に <xref linkend="sec.new.bash.fildir.ex"/> の流れに従って作業を行なっていた場合、履歴機能としていくつかのコマンドラインが記憶されているはずです。下記では、既に上述の流れを実施していて、履歴が存在する場合の手順を示しています。</para>
    <step>
     <para>まずは <command>cd ~</command> が現われるまで、 <keycap function="up"/> を何度も押していきます。</para>
    </step>
    <step>
     <para><keycap function="enter"/> を押してコマンドを実行すると、ホームディレクトリへの移動が行なわれます。</para>
     <para><!-- NOTE: When in environment other than English, "Documents" will be translated to something. But it may be difficult to input within terminal. So we changed the explanation in this translation. -->たとえば、お使いのホームディレクトリ内に <filename>Documents</filename> と <filename>Desktop</filename> というディレクトリがあるものとします。</para>
    </step>
    <step>
     <para>まずは <command>cd D</command> まで入力して <keycap function="tab"/> を押します。</para>
     <para>押しても特に何も起こりません。 bash は複数のディレクトリが存在することを知っているためです。</para>
    </step>
    <step>
     <para>再度 <keycap function="tab"/> を押すと、選択肢が表示されます:</para>
     <screen>&prompt.user;<command>cd D</command>
Desktop/ Documents/ Downloads/
&prompt.user;<command>cd D</command></screen>
    </step>
    <step>
     <para>プロンプトは入力した時点のままの表示になっています。ここからさらに文字を入力して <keycap function="tab"/> を押します。</para>
     <para>これで bash は残りの文字を埋めるようになります。</para>
    </step>
    <step>
     <para>コマンドラインの入力が終わったら、 <keycap function="enter"/> を押すと実行することができます。</para>
    </step>
   </procedure>
   <procedure>
    <title>ワイルドカードの使用</title>
    <para>この例では、お使いのホームディレクトリ内に様々な拡張子のファイルが存在していて、<filename>myfile1.txt</filename> , <filename>myfile2.txt</filename> など、異なるファイル名で複数のバージョンのファイルが保存されているものとします。このときのワイルドカードの使い方を説明しています。</para>
    <step>
     <para>まずはホームディレクトリ内に、いくつかのテストファイルを作成します:</para>
     <substeps>
      <step>
       <para><command>touch</command> コマンドを利用して、いくつかの (中身が空の) ファイルを作成します。たとえば <filename>.pdf</filename> , <filename>.xml</filename> , <filename>.jpg</filename> などの拡張子で作成します。</para>
       <para>ファイルの作成は、 bash の履歴機能を利用すれば繰り返し (ファイル名を変えながら) 実行できますし、 <command>touch</command> コマンドは複数のファイルを指定することができますので、スペース区切りでファイル名を複数指定して、一括で実行してもかまいません。</para>
      </step>
      <step>
       <para>また、同じ拡張子 (たとえば <filename>.html</filename>) のファイルを 2 つ用意します。</para>
      </step>
      <step>
       <para>さらに、連続した数字を付与したファイルを複数作成します。下記のように実行します:</para>
<screen>&prompt.user;touch myfile{1..5}.txt</screen>
       <para>上記のコマンドを実行すると、 <filename>myfile1.txt</filename> , &hellip;, <filename>myfile5.txt</filename> をそれぞれ作成します。</para>
      </step>
      <step>
       <para>まずはディレクトリの内容を一覧表示します。下記のような出力になるはずです:</para>
       <screen>&prompt.user;ls -l
合計 0
-rw-r--r-- 1 tux users 0  7月 14 13:34 foo.xml
-rw-r--r-- 1 tux users 0  7月 14 13:47 home.html
-rw-r--r-- 1 tux users 0  7月 14 13:47 index.html
-rw-r--r-- 1 tux users 0  7月 14 13:47 toc.html
-rw-r--r-- 1 tux users 0  7月 14 13:34 manual.pdf
-rw-r--r-- 1 tux users 0  7月 14 13:49 myfile1.txt
-rw-r--r-- 1 tux users 0  7月 14 13:49 myfile2.txt
-rw-r--r-- 1 tux users 0  7月 14 13:49 myfile3.txt
-rw-r--r-- 1 tux users 0  7月 14 13:49 myfile4.txt
-rw-r--r-- 1 tux users 0  7月 14 13:49 myfile5.txt
-rw-r--r-- 1 tux users 0  7月 14 13:32 tux.png</screen>
      </step>
     </substeps>
    </step>
    <step>
     <para>ワイルドカードを使用すると、様々な条件を指定して一部のファイルを効率的に指定することができます:</para>
     <substeps>
      <step>
       <para><filename>.html</filename> という拡張子のファイルを全て表示するには、下記のように実行します:</para>
<screen>&prompt.user;ls -l *.html</screen>
      </step>
      <step>
       <para><filename>myfile<replaceable>数字</replaceable>.txt</filename> のファイルを一覧表示するには、下記のように実行します:</para>
<screen>&prompt.user;ls -l myfile?.txt</screen>
       <para>上記の例では <literal>?</literal> というワイルドカードを使用していますが、これはファイルの数字部分が 1 桁のものしか表示することができないことに注意してください。たとえば <filename>myfile10.txt</filename> というファイルが存在する場合、このファイルを含めるには <literal>?</literal> を <literal>*</literal> に変更する必要があります。また、数字部分が 2 桁のもののみを一覧表示するには、 <command>myfile??.txt</command> となります。</para>
      </step>
      <step>
       <para><filename>myfile1.txt</filename> , <filename>myfile2.txt</filename> , <filename>myfile3.txt</filename> , <filename>myfile5.txt</filename> をそれぞれ削除するには、下記のように実行します:</para>
<screen>&prompt.user;rm myfile[1-3,5].txt</screen>
      </step>
      <step>
       <para>下記を実行すると、結果を確認することができます:</para>
<screen>&prompt.user;ls -l</screen>
       <para>削除を行なった後は、 <filename>myfile4.txt</filename> ファイルだけが残っているはずです。</para>
      </step>
     </substeps>
    </step>
   </procedure>
   <para>なお、複数のワイルドカードを同時に指定することもできます。たとえば上記の例では、 <command>rm myfile[1-3,5].*</command> と実行しても、 <command>rm myfile[1-3,5].txt</command> と同じ結果になります。これは、該当するファイルが全て <filename>.txt</filename> という拡張子であるためです。</para>
   <note>
    <title><command>rm</command> コマンドでのワイルドカードについて</title>
    <para><command>rm</command> コマンドを使用する際、ワイルドカードの使用は非常に便利なものですが、その反面として危険性もはらんでいます。場合によっては、必要以上にファイルを削除してしまうこともあります。何が削除されるのかを事前に確認するため、まずは <command>rm</command> の前に <command>ls</command> を利用して、ワイルドカードを指定しておくことをお勧めします。</para>
   </note>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.new.bash.edit">
  <title>テキストの編集</title>

  <para>コマンドラインからファイルを編集するには、 vi エディタの使用方法を知っておく必要があります。 vi はほとんどの UNIX/Linux システムで利用できる既定のエディタです。 vi ではモードと呼ばれる概念があり、これによってキーを入力しても異なる動作になるようになっています。ただし、初心者には少しわかりにくい仕組みであることから、本章でごく基本的な操作方法を説明しています。なお、場合によっては vi エディタしか利用できない状況もあります。</para>

  <para>基本的には、 vi には 3 種類の操作モードがあります:</para>

  <variablelist>
   <varlistentry>
    <term><emphasis>コマンド</emphasis> モード</term>
    <listitem>
     <para>このモードでは、 vi はキーの組み合わせをコマンドとして解釈します。単語の検索や行の削除などの作業を行なうことができます。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><emphasis>挿入</emphasis> モード</term>
    <listitem>
     <para>このモードでは、通常のテキストをそのまま入力することができます。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><emphasis>拡張</emphasis> モード</term>
    <listitem>
     <para>このモードは、切り替える際に <literal>:</literal> を入力することから、コロンモードとも呼ばれ、テキストの検索や置換などのより複雑な処理を行なうことができます。</para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>下記の (非常にシンプルな) 例では、 vi でファイルを開いて編集し、保存を行なって終了するまでの流れを説明しています。</para>

  <sect2 xml:id="sec.new.bash.edit.ex">
   <title>例: vi での編集</title>
   <procedure>
    <note>
     <title>キーの表示</title>
     <para>下記の例では様々なコマンドを入力していますが、 vi でのキー入力は基本的に小文字で行ないます。下記の説明では、敢えて大文字を必要とする場合に限り、 <keycap function="shift"/> を含めたキー入力で表わしています。</para>
    </note>
    <step>
     <para>vi で新しくファイルを作成して開くには、下記のように実行します:</para>
<screen>&prompt.user;vi textfile.txt</screen>
     <para>既定では、 vi は <emphasis>コマンド</emphasis> モードで起動します。ここでは、直接テキストを入力することはできません。</para>
    </step>
    <step>
     <para><keycap>I</keycap> を押して挿入モードに切り替えます。最下行の表示が変化しますので、テキストを挿入できる状態になっていることが分かります。</para>
    </step>
    <step>
     <para>何かテキストを記述します。改行を挿入したい場合は、まず <keycap function="escape"/> を押してコマンドモードに戻り、 <keycap>O</keycap> を押して改行を入れ、再度挿入モードに戻ります。</para>
    </step>
    <step>
     <para>挿入モードでは、矢印 (カーソル) キーと <keycap function="delete"/> でテキストを編集することができます。</para>
    </step>
    <step>
     <para>vi を終了するには、まず <keycap function="escape"/> を押してコマンドモードに切り替えます。そこから <keycap>:</keycap> を押して拡張モードに切り替えます。最下行にコロンが表示されるようになります。</para>
    </step>
    <step>
     <para>記入した内容を保存して vi を終了するには、 <command>wq</command> ( <literal>w</literal> は <literal>write</literal> (書き込む) の意味、 <literal>q</literal> は <literal>quit</literal> (終了) の意味 ) と入力して <keycap function="enter"/> を押します。ファイル名を変えて保存したい場合は、 <command>w <replaceable>ファイル名</replaceable></command> のように入力して <keycap function="enter"/> を押します。</para>
     <para>保存せずに vi を終了するには、 <command>q!</command> と入力して <keycap function="enter"/> を押します。</para>
    </step>
   </procedure>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.new.bash.search">
  <title>ファイルやその内容の検索</title>

  <para>bash には、ファイル名やファイルの内容を検索する方法がいくつか用意されています:</para>

  <variablelist>
   <varlistentry>
    <term><command>find</command></term>
    <listitem>
     <para><command>find</command> は指定したディレクトリ内でファイルを検索するためのコマンドです。最初のパラメータで検索を開始するディレクトリを指定します。以降はオプションで、 <option>-name</option> はファイル名に対する条件を指定します (ワイルドカードでも指定できます) 。なお、データベースを使用する <command>locate</command> コマンドとは異なり、 <command>find</command> は実際のディレクトリをそのまま検索します。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><command>grep</command></term>
    <listitem>
     <para><command>grep</command> はファイルの内容を検索するためのコマンドで、主にテキストファイル内の検索を行ないます。検索文字列に合致した箇所が見つかると、このコマンドはファイル名と行全体を表示します。必要であれば、ファイル名にワイルドカードを指定することもできます。</para>
    </listitem>
   </varlistentry>
  </variablelist>

  <sect2>
   <title>検索例</title>
   <itemizedlist>
    <listitem>
     <para>ホームディレクトリ内のファイルを検索し、 <filename>.txt</filename> という拡張子のファイルだけを表示するには、下記のように実行します:</para>
<screen>&prompt.user;find ~ -name '*.txt' -print</screen>
    </listitem>
    <listitem>
     <para>たとえば <literal>music</literal> という文字列を内容に含むファイルを、ホームディレクトリ以下から検索するには、下記のように実行します:</para>
<screen>&prompt.user;grep music ~/*</screen>
     <para><command>grep</command> は既定では大文字と小文字を区別して動作します。そのため、上記のコマンドでは <literal>Music</literal> という文字列は検索に該当しないことになります。大文字と小文字を区別しない場合は、 <option>-i</option> オプションを指定してください。</para>
    </listitem>
    <listitem>
     <para>複数の単語からなる文字列を検索する場合は、文字列を引用符で括ってください。たとえば下記のようになります:</para>
<screen>&prompt.user;grep "music is great" ~/*</screen>
    </listitem>
   </itemizedlist>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.new.bash.view">
  <title>テキストファイルの表示</title>

  <para><command>grep</command> でファイルの内容を検索した場合、検索文字列に該当したファイル名とその行のみが表示されます。ただ、場合によっては、これだけでは情報不足で、本当に目的のファイルかどうかが判断できない場合があります。このような場合に備え、 bash ではエディタを利用することなく、テキストファイルの内容を表示する機能を複数用意しています。</para>

  <variablelist>
   <varlistentry>
    <term><command>head</command></term>
    <listitem>
     <para><command>head</command> はテキストファイルの冒頭の複数行を表示するコマンドです。特に何も指定しない場合は、テキストファイルの冒頭 10 行分を表示します。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><command>tail</command></term>
    <listitem>
     <para><command>tail</command> コマンドは <command>head</command> コマンドの逆で、何も指定しない場合はテキストファイルの末尾 10 行を表示します。これは特に、システムのログファイルを閲覧する場合に便利なコマンドです。ログファイルの末尾には直近のログが記録されていますので、直近の情報を取得する際にはこのコマンドを使うとよいでしょう。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><command>less</command></term>
    <listitem>
     <para><command>less</command> を使用すると、テキストファイルの全体を表示することができます。また、 <keycap function="pageup"/> や <keycap function="pagedown"/> のキーを押すと、それぞれ半ページ単位で移動 (スクロール) することもできます。また、 <keycap function="space"/> は 1 ページ分下に移動することができるほか、 <keycap function="home"/> でファイルの冒頭に、 <keycap function="end"/> でファイルの末尾にそれぞれ移動することができます。表示を終了するには、 <keycap>Q</keycap> を押してください。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><command>more</command></term>
    <listitem>
     <para><literal>less</literal> の代用として <literal>more</literal> というコマンドを使用することもできます。同じような機能を持つコマンドですが、 <literal>more</literal> はファイルの冒頭方向に戻る機能がないため、少し不便なコマンドではあります。末尾の方向に進むには <keycap function="space"/> を押します。ファイルの末尾まで到達すると、 <literal>more</literal> は自動的に終了します。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><command>cat</command></term>
    <listitem>
     <para><command>cat</command> はファイルの内容を表示するコマンドで、ファイル全体を止まることなくそのまま出力します。 <command>cat</command> にはスクロールのような機能がないので、非常に使いづらく思えてしまいますが、しばしば他のコマンドと組み合わせて使用するためのコマンドです。</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
 <sect1 xml:id="sec.new.bash.redir">
  <title>リダイレクトとパイプ</title>
  <para>作業内容によっては、コマンドの出力した結果をファイルに出力したり、複数のコマンドを組み合わせて、一方のコマンドの出力を他方のコマンドの入力として使用したりしたい場合があります。シェルでは、このような仕組みをリダイレクトやパイプとして提供しています。</para>

  <para>通常、シェルの標準的な出力先 (標準出力) は画面 (シェルのウインドウ) に、標準的な入力元 (標準入力) はキーボードにそれぞれ設定されています。それぞれ対応するシンボルを指定することで、入出力を他のファイルやコマンドに流すことができます。</para>

  <variablelist>
   <varlistentry>
    <term>リダイレクト</term>
    <listitem>
     <para><literal>&gt;</literal> というシンボルを指定すると、出力結果をファイルに流す (リダイレクトする) ことができます (出力リダイレクト) 。また、 <literal>&lt;</literal> というシンボルを指定すると、逆にファイルの内容を入力として使用することができます　(入力リダイレクト) 。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>パイプ</term>
    <listitem>
     <para>パイプ記号 (<literal>|</literal>) を使用しても、出力をリダイレクトすることができます。ただし、パイプ記号の場合、出力先はファイルではなく次のコマンドになります。つまり、複数のコマンドをパイプで繋げて指定すれば、前のコマンドの出力を次のコマンドの入力として使用できることになります。</para>
    </listitem>
   </varlistentry>
  </variablelist>

  <sect2 xml:id="sec.new.bash.redir.ex">
   <title>リダイレクトとパイプの例</title>
   <procedure>
    <step>
     <para><command>ls</command> の出力をファイルに保存するには、下記のように実行します:</para>
<screen>&prompt.user;ls -l &gt; filelist.txt</screen>
     <para>このコマンドを実行すると、カレントディレクトリに <filename>filelist.txt</filename> というファイルが作成され、 <command>ls</command> の出力結果が書き込まれます。</para>
     <para>ただし、コマンドの実行よりも前に <filename>filelist.txt</filename> というファイルが存在していると、このコマンドを実行することでファイルが上書きされてしまいます。これを防ぐには、 &gt; ではなく <literal>&gt;&gt;</literal> と指定します。たとえば下記のようになります:</para>
<screen>&prompt.user;ls -l &gt;&gt; filelist.txt</screen>
     <para>上記を実行すると、 <command>ls</command> コマンドの出力が、既存の <filename>filelist.txt</filename> ファイルに追記されるようになります。なお、ファイルが存在しない場合は、新規に作成されます。</para>
    </step>
    <step>
     <para>リダイレクトは逆方向にも使用することができます。キーボードからの入力ではなく、ファイルからの入力を行ないたい場合は、たとえば下記のように実行します:</para>
<screen>&prompt.user;sort &lt; filelist.txt</screen>
     <para>上記を実行すると、 <filename>filelist.txt</filename> の内容を読み込んで、それを並べ替え (sort) て出力します。出力先は画面になります。リダイレクトを組み合わせれば、結果を他のファイルに流すこともできます:</para>
<screen>&prompt.user;sort &lt; filelist.txt &gt; sorted_filelist.txt</screen>
    </step>
    <step>
     <para>たとえば <command>ls</command> <option>-l</option> など、コマンドが長い出力を生成するような場合、パイプを利用して <literal>less</literal> のようなコマンドに流すことで、出力結果をスクロールしながら読むことができるようになります。たとえば下記のようになります:</para>
<screen>&prompt.user;ls -l | less</screen>
     <para>上記のように実行することで、カレントディレクトリの内容を <literal>less</literal> で読むことができるようになります。</para>
     <para>パイプは、しばしば <command>grep</command> コマンドとも併用します。これは、出力された内容から特定の文字列を含む箇所だけを抜き出して表示する際に利用するもので、たとえば下記を実行すると、 &exampleuser; が所有するファイルだけを出力することができます:</para>
<screen>&prompt.user;ls -l | grep tux</screen>
    </step>
   </procedure>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.new.bash.jobs">
  <title>プログラムの起動とプロセスの管理</title>

  <para><xref linkend="sec.new.bash.edit"/> で示しているとおり、シェルからは様々なプログラムを起動することができます。プログラムによっては、 X Window System のようなグラフィカルユーザインターフェイス (GUI) を持つものもあります。たとえば KDE や GNOME をお使いの環境で、ホームディレクトリ内にある <filename>vacation.pdf</filename> というファイルを読みたい場合、 <command>okular&nbsp;~/vacation.pdf</command> (もしくは <command>evince&nbsp;~/vacation.pdf</command> ) と入力すると、 PDF ビューアが起動して PDF ファイルを表示することができます。</para>

  <para> PDF ビューアを開いている間、端末ウインドウのほうをご覧ください。プロンプトが表示されていないことに気がつくかと思います。つまり、この時点では何もコマンドを受け付けなくなっています。 PDF ビューアを終了すると、再度プロンプトが表示されるようになり、コマンドも実行できるようになります。このような問題を回避するには、プログラム (例: PDF ビューア) を起動している間に <keycombo> <keycap function="control"/> <keycap>Z</keycap> </keycombo> を押してプロセス (処理) を一時停止し、 <command>bg</command> と入力してプロセスをバックグラウンド (裏) で動作させることができます。</para>
  <para>これで <filename>vacation.pdf</filename> を表示しながら、同じ端末でさらなるコマンドを入力できるようになりました。ただし、いちいち上記のような手順を行なっても面倒なので、最初からバックグラウンドで動作させる方法もあります。これを行なう場合には、コマンドの末尾にアンパサンド (<literal>&amp;</literal>) を付けます:</para>

<screen>&prompt.user;okular ~/vacation.pdf &amp;</screen>

  <para>バックグラウンドプロセス (シェル内では <quote>ジョブ</quote> とも言います) を起動している場合、 <command>jobs</command> というコマンドを実行することで、存在するジョブを一覧で表示することができます。ジョブにはそれぞれ番号が付けられています ([] 内の番号がジョブ番号です):</para>

<screen>&prompt.user;jobs
[1]   実行中         okular book.opensuse.startup-xep.pdf &amp;
[2]-  停止           okular book.opensuse.reference-xep.pdf &amp;
[3]+  停止           man jobs</screen>

  <para>ジョブを再度フォアグラウンド (表) に戻すには、 <command>fg <replaceable>ジョブ番号</replaceable></command> と入力して実行します:</para>

  <para><command>job</command> コマンドは、端末から起動したバックグラウンドプロセスのみを表示することができますが、 <command>ps</command> コマンドでは、何もオプションを指定しなければ、自分自身のユーザに紐付く全てのプロセスを表示することができます。たとえば下記のような出力になります:</para>

<screen>&prompt.user;ps
PID TTY          TIME CMD
15500 pts/1    00:00:00 bash
28214 pts/1    00:00:00 okular
30187 pts/1    00:00:00 kwrite
30280 pts/1    00:00:00 ps</screen>

  <para>通常の手段ではプログラムを終了できなくなってしまった場合は、 <command>kill</command> コマンドを利用してプロセスに対応するプログラムを停止させることができます。これを行なうには、 <command>ps</command> の出力で得られるプロセス ID (PID) を指定する必要があります。たとえば上記の出力で、 kwrite を終了させたい場合は、下記のように実行します:</para>

<screen>&prompt.user;kill 30187</screen>

  <para>これでプログラムに対して <emphasis>TERM</emphasis> というシグナルが送信され、プログラムを終了するよう指示することができます。</para>

  <para>上記の方法以外にも、 <command>jobs</command> コマンドで表示されるジョブ番号を指定して終了させることもできます。この場合は、ジョブ番号の前にパーセント記号 ( <literal>%</literal> ) を指定します:</para>

<screen>&prompt.user;kill %<replaceable>ジョブ番号</replaceable></screen>

  <para>場合によっては、通常の <command>kill</command> コマンドでも終了しなくなってしまう場合もあります。この場合は下記のように実行してみてください:</para>

<screen>&prompt.user;kill -9 <replaceable>PID</replaceable></screen>

  <para>上記を実行すると、 <emphasis>TERM</emphasis> シグナルではなく、 <emphasis>KILL</emphasis> というシグナルが送信されるようになります。通常は、これでプログラムを強制終了させることができます。</para>

  <para>本章は、ジョブとプロセスに関するごく基本的なコマンドについて紹介してきました。システム管理者の場合は、 <xref linkend="sec.util.processes"/> も合わせてお読みになることをお勧めします。</para>
 </sect1>

 <sect1 xml:id="sec.bash.tar">
  <title>書庫 (アーカイブ) とデータ圧縮</title>
  <para>Linux では、 2 種類のコマンドを使用してデータを転送しやすい形にすることができます:</para>
  <itemizedlist>
   <listitem>
    <para>1 つは書庫プログラムと呼ばれ、複数の (一般的には多数の) ファイルを 1 つのファイルにまとめます。一般的には <command>tar</command> や <command>cpio</command> などを使用します。</para>
   </listitem>
   <listitem>
    <para>もう 1 つはデータ圧縮プログラムと呼ばれ、元のデータに展開できる状態を維持しながら、よりファイルを小さくします。一般的には <command>gzip</command> や <command>bzip2</command> を使用します。</para>
   </listitem>
  </itemizedlist>
  <para>上記 2 種類のコマンドを組み合わせて使用することで、データ圧縮型書庫を実現することができます。他のオペレーティングシステムでは <filename>ZIP</filename> や <filename>RAR</filename> などと呼ばれるファイルです。</para>
  <para>たとえば <filename>test</filename> ディレクトリ以下の全てのファイルとサブディレクトリを、 <filename>testarchive.tar</filename> というファイルにまとめたい場合は、下記のように実行します:</para>
  <procedure xml:id="pro.bash.archive">
   <title>ファイルの書庫の作成</title>
   <step>
    <para>シェルを開きます。</para>
   </step>
   <step>
    <para><command>cd</command> コマンドを利用して、 <filename>test</filename> ディレクトリのある場所まで移動します。</para>
   </step>
   <step>
    <para>書庫の作成は下記のようにして行ないます:</para>
    <screen>&prompt.user;tar -cvf testarchive.tar test</screen>
    <para><option>-c</option> オプションは書庫の作成を、 <option>-v</option> オプションは処理したファイルの情報を出力する指示を、 <option>-f</option> オプションは出力先のファイルの指定を、それぞれ行なっています。</para>
    <para><filename>test</filename> ディレクトリに存在していたファイルやディレクトリは、そのまま削除されずそのまま保持されます。</para>
   </step>
   <step>
    <para>書庫ファイルの内容を表示するには、下記のように実行します:</para>
    <screen>&prompt.user;tar -tf testarchive.tar</screen>
   </step>
   <step>
    <para>書庫の内容を展開するには、下記のように実行します:</para>
    <screen>&prompt.user;tar -xvf testarchive.tar</screen>
    <para>なお、カレントディレクトリ以下に書庫内と同じファイルやディレクトリが存在する場合、それらは何も警告されることなく上書きされます。</para>
   </step>
  </procedure>

  <para>ファイルを圧縮するには、 <command>gzip</command> または <command>bzip2</command> コマンドを使用します。後者のほうが、より高い圧縮率になります。</para>
  <procedure xml:id="pro.bash.compress">
   <title>ファイルの圧縮</title>
   <step>
    <para>下記の例では、 <xref linkend="pro.bash.archive"/> で作成した書庫をそのまま使用しています。</para>
    <para>書庫を圧縮するには、下記のように実行します:</para>
    <screen>&prompt.user;gzip testarchive.tar</screen>
    <para><command>ls</command> コマンドを実行するとわかりますが、上記のコマンドを実行すると <filename>testarchive.tar</filename> というファイルが削除され、その代わりに <filename>testarchive.tar.gz</filename> というファイルが作成されます。</para>
    <para>上記以外にも、 <command>bzip2 testarchive.tar</command> のように実行すると、より高い圧縮率で圧縮を行なうことができます。</para>
   </step>
   <step>
    <para>今度は圧縮を展開して、書庫からファイルを取り出してみます:</para>
    <itemizedlist>
     <listitem>
      <para>書庫を作成して圧縮した手順とは逆に、圧縮を展開してから書庫の内容を取り出します:</para>
<screen>
&prompt.user;<command>gzip --decompress testarchive.tar.gz</command>
&prompt.user;<command>tar -xvf testarchive.tar</command>
</screen>
     </listitem>
     <listitem>
      <para>展開と取り出しを一括で行なうこともできます:</para>
      <screen>&prompt.user;tar -xvf testarchive.tar</screen>
     </listitem>
    </itemizedlist>
    <para><command>ls</command> を実行すると、新しく <filename>test</filename> というディレクトリが作成され、ホームディレクトリにある <filename>test</filename> ディレクトリと同じ内容が作成されます。</para>
   </step>
  </procedure>
 </sect1>

 <xi:include href="newbie_bash_commands_i.xml"/>

</chapter>
